{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p> Alex Aiken   Alcatel-Lucent Professor, Stanford University   Computer Science Division Director, SLAC   </p> <p></p> <p>past portraits</p>"},{"location":"#contact","title":"Contact Information","text":"<ul> <li> <p>Alex Aiken</p> <ul> <li>Email: aaiken@stanford.edu</li> <li>Office: E462 CoDa</li> <li>Phone: 650-725-3359</li> </ul> </li> <li> <p>Assistant</p> <ul> <li>Name: Opeta Henderson</li> <li>Email: opetah@stanford.edu</li> <li>Phone: 650-721-1166</li> </ul> </li> </ul>"},{"location":"#bio","title":"Biographical Sketch","text":"<p>Alex Aiken is the Alcatel-Lucent Professor of Computer Science at Stanford. Alex received his Bachelors degree in Computer Science and Music from Bowling Green State University in 1983 and his Ph.D. from Cornell University in 1988. Alex was a Research Staff Member at the IBM Almaden Research Center (1988-1993) and a Professor in the EECS department at UC Berkeley (1993-2003) before joining the Stanford faculty in 2003. His research interest is in areas related to programming languages. He is an ACM Fellow, a recipient of ACM SIGPLAN's Programming Languages Achievement Award and Phi Beta Kappa's Teaching Award, and a former chair of the Stanford Computer Science Department.</p> <p>Alex is married to Jennifer Widom. Jennifer and Alex have a son Tim and a daughter Emily. Here are some photos from the family's travels.</p>"},{"location":"#announcements","title":"Announcements","text":"<ul> <li>2/2024 Here are the talks and slides from the 2024 Legion   Retreat.</li> </ul>"},{"location":"#teaching","title":"Teaching","text":"<ul> <li>CS242: Programming Languages</li> <li>CS315B: Programming Supercomputers</li> <li>My publicly available, free, self-study compilers   course. The course covers the essentials of compiler   construction, plus material on language design and semantics, optimization, and bit on the history   of programming languages. There are optional programming assignments for hard-core enthusiasts who   want to build a full, functioning compiler for   COOL, the Classroom Object Oriented   Language.</li> <li>Stanford Software Seminar</li> <li>The weekly software research lunch.</li> </ul>"},{"location":"#research","title":"Research Projects","text":"<ul> <li>FlexFlow is a system for automatically finding fast parallelization   strategies for deep learning training and inference. FlexFlow is built on Legion (see below).</li> <li>Legion is a programming system for heterogeneous, parallel machines   with complex memory hierarchies.</li> <li>A Regent tutorial</li> <li>A Legion tutorial</li> </ul> <p>I also maintain a page of past research projects and a set of pages internal to current projects.</p>"},{"location":"#misc","title":"Miscellany","text":"<ul> <li>Here's a recent trip   report from a winter   crossing of the wilderness areas west of Lake Tahoe.</li> <li>I gave the commencement speech at CS graduation during the time I was department chair (well, I   did miss one year ...). I've received requests for links to those speeches, so here they are:   2015,   2017, and   2018.</li> <li>If my bio is too short for you, People of PLDI has published an interview with   me, along with a number of other PL   researchers.</li> <li>In 2018 I celebrated the (almost) end of my term as department chair by hiking the Sierra High   Route. Here is the trip report.</li> <li>Advice for Program Chairs distills my experience (and things   I've learned from many other people) as a program chair for POPL and PLDI.</li> <li>I delivered a memorial for John Backus at PLDI'07.</li> <li>My family took most of the '07-'08 academic year off to travel the world. Those with too much time   on their hands can check out the trip's web   page.</li> </ul>"},{"location":"#students","title":"Current Ph.D. and Postdoctoral Students","text":"<ul> <li>Benjamin Driscoll</li> <li>Qiantan Hong</li> <li>Rupanshu Soi</li> <li>Colin Unger</li> <li>Tony Wang</li> <li>Anjiang Wei</li> <li>Rohan Yadav</li> <li>David Zhang</li> </ul>"},{"location":"alternatepics/","title":"Alternatepics","text":"<ul> <li> <p>In the good old days.</p> </li> <li> <p></p> <p>Some pretty good days, too.</p> </li> <li> <p></p> <p>And a bit later.</p> </li> <li> <p></p> <p>And even later.</p> </li> <li> <p></p> <p>Another decade on.</p> </li> <li> <p></p> <p>Around the same time.</p> </li> <li> <p></p> <p>Just a few years later.</p> </li> <li> <p></p> <p>And another half decade.</p> </li> </ul>"},{"location":"bio/","title":"Bio","text":""},{"location":"bio/#bio","title":"Bio","text":"<p>You are being redirected to the Biographical Sketch section on the Home page.</p> <p>Go to Bio </p>"},{"location":"misc/","title":"Misc","text":""},{"location":"misc/#misc","title":"Misc","text":"<p>You are being redirected to the Miscellany section on the Home page.</p> <p>Go to Misc </p>"},{"location":"pastprojects/","title":"Pastprojects","text":""},{"location":"pastprojects/#past-research-projects","title":"Past Research Projects","text":"<p>All good things must come to and end, and to start something new we have to stop something old, and so on and so forth. Below is a list of past research projects that I have worked but are no longer active, or at least the activity is now irregular and unpredictable.</p> <p>Lux is a system for high performance distributed graph processing, is now available. Lux is built on top of Legion.</p> <p>STOKE is a stochastic optimizer and associated verification techniques for X86 binaries.</p> <p>DeduceIt is a system for checking student derivations in on-line courses; the idea is to provide a richer and more interactive electronic homework than multiple choice questions for problems that can be formulated as derivations in some formal system. A number of things are available:</p> <ul> <li>A demo video if you just want to get an idea of   how it works.</li> <li>The live DeduceIt system (which is   currently broken, sorry!), where you can try a number of different   kinds of exercises developed for the undergraduate compiler course I   teach.</li> <li>Open source repositories for the web   front-end and the theorem   prover back-end if you want   to hack on the system yourself.</li> </ul> <p>Sequoia: Programming Hierarchical Memory Machines</p> <p>Saturn: a SAT-based tool for static error detection.</p> <ul> <li>There is a Saturn   release   available for download.</li> </ul> <p>Chord: Effective Static Race Detection.</p> <p>Cooperative Bug Isolation</p> <ul> <li>CBI Talk</li> </ul> <p>CQual: Adding specifications to programs with programmer-defined type qualifiers.</p> <p>Banshee, daughter of BANE, the Berkeley ANalysis Engine for constructing constraint-based program analyses.</p> <p>CAP: Search millions of lines of open source for your code.</p> <p>Open Source Quality Project: Applying technology to software engineering problems.</p> <p>Titanium: Compiler support for explicit parallel programming.</p> <p>Cool: A freely available course project for teaching compilers to undergraduates.</p> <p>Moss: A Measure of Software Similarity, useful for detecting plagiarism in programming assignments.</p>"},{"location":"phds/","title":"Graduated Students","text":""},{"location":"phds/#graduated-phd-students","title":"Graduated Ph.D. Students","text":"<p>Since I became a professor in 1993, I've been privileged to work with great Ph.D. students. Nothing defines the professional life of a research faculty member more than the graduate students they work with, and my professional life has been fun and rewarding. Below is a list of the students who have graduated with me as their primary advisor, their thesis, and their current affiliation, if I know it.</p> <p>Manuel F\u00e4hndrich</p> <ul> <li>Berkeley, 1999</li> <li>Facebook</li> <li>Thesis: BANE: A Library for Scalable Constraint-Based Program   Analysis</li> </ul> <p>David Gay</p> <ul> <li>Berkeley, 2001</li> <li>Google</li> <li>Thesis: Memory Management with Explicit   Regions</li> </ul> <p>Jeff Foster</p> <ul> <li>Berkeley, 2002</li> <li>Professor, Tufts University</li> <li>Thesis: Type Qualifiers: Lightweight Specifications to Improve   Software Quality</li> </ul> <p>Zhendong Su</p> <ul> <li>Berkeley, 2002</li> <li>Professor, ETH</li> <li>Thesis: Algorithms for and the Complexity of Constraint   Entailment</li> </ul> <p>Ben Liblit</p> <ul> <li>Berkeley, 2004</li> <li>Amazon</li> <li>Thesis: Cooperative Bug Isolation</li> </ul> <p>John Kodumal</p> <ul> <li>Berkeley, 2006</li> <li>CTO, LaunchDarkly</li> <li>Thesis: Program Analysis with Regularly Annotated   Constraints</li> </ul> <p>Tachio Terauchi</p> <ul> <li>Berkeley, 2006</li> <li>Professor, Waseda University</li> <li>Thesis: Types for Deterministic   Concurrency</li> </ul> <p>Yichen Xie</p> <ul> <li>Stanford, 2006</li> <li>SAC Capital</li> <li>Thesis: Static Detection of Software   Errors</li> </ul> <p>Sorav Bansal</p> <ul> <li>Stanford, 2008</li> <li>Professor, IIT Delhi</li> <li>Thesis: Peephole Superoptimization</li> </ul> <p>Simon Goldsmith</p> <ul> <li>Berkeley, 2008</li> <li>Coverity</li> <li>Thesis: Measuring Empirical Computational   Complexity</li> </ul> <p>Mayur Naik</p> <ul> <li>Stanford, 2008</li> <li>Professor, University of Pennsylvania</li> <li>Thesis: Effective Static Race Detection for   Java</li> </ul> <p>Adam Oliner</p> <ul> <li>Stanford, 2011</li> <li>Graft</li> <li>Thesis: Using Influence to Understand Complex   Systems</li> </ul> <p>Isil Dillig</p> <ul> <li>Stanford, 2011</li> <li>Professor, University of Texas at Austin</li> <li>Thesis: Precise and Automatic Verification of Containter-   Manipulating Programs</li> </ul> <p>Thomas Dillig</p> <ul> <li>Stanford, 2011</li> <li>Blu Sphinx</li> <li>Thesis: A Modular and Symbolic Approach to Static Program   Analysis</li> </ul> <p>Brian Hackett</p> <ul> <li>Stanford, 2011</li> <li>Replay</li> <li>Thesis: Type Safety in the Linux   Kernel</li> </ul> <p>Peter Hawkins</p> <ul> <li>Stanford, 2012</li> <li>Google</li> <li>Thesis: Data Representation   Synthesis</li> </ul> <p>Michael Bauer</p> <ul> <li>Stanford, 2014</li> <li>Nvidia Research</li> <li>Thesis: Programming Distributed Heterogeneous Architectures with   Logical Regions</li> </ul> <p>Eric Schkufza</p> <ul> <li>Stanford, 2015</li> <li>Amazon</li> <li>Thesis: Stochastic Program Optimization for x86_64   Binaries</li> </ul> <p>Rahul Sharma</p> <ul> <li>Stanford, 2016</li> <li>Microsoft Research</li> <li>Thesis: Data-Driven Verification</li> </ul> <p>Sean Treichler</p> <p>Stanford, 2016</p> <p>Nvidia</p> <p>Thesis: Realm: Performance Portability Through Composable Asynchrony</p> <p>Elliott Slaughter</p> <ul> <li>Stanford, 2017</li> <li>SLAC</li> <li>Thesis: Regent: A High Productivity Programming Language for   Implicit Parallelism with Logical   Regions</li> </ul> <p>Osbert Bastani</p> <ul> <li>Stanford, 2017</li> <li>Assistant Professor, University of Pennsylvania</li> <li>Thesis: Beyond Deductive Inference in Program   Analysis</li> </ul> <p>Lazaro Clapp</p> <ul> <li>Stanford, 2017</li> <li>Uber</li> <li>Thesis: Specification Mining and Automated Testing of Mobile   Applications</li> </ul> <p>Stefan Heule</p> <ul> <li>Stanford, 2018</li> <li>Google</li> <li>Thesis: Guided Randomized Search Over Programs for Synthesis and   Program Optimization</li> </ul> <p>Berkeley Churchill</p> <ul> <li>Stanford, 2019</li> <li>Thesis: Blackox Equivalence Checking of Program   Optimizations</li> </ul> <p>Manolis Papadakis</p> <ul> <li>Stanford, 2019</li> <li>Nvidia</li> <li>Thesis: New Directions in Uncertainty Quantification using   Task-Based Programming</li> </ul> <p>Wonchan Lee</p> <ul> <li>Stanford, 2019</li> <li>Nvidia</li> <li>Thesis: A Hybrid Approach to Automatic Program Parallelization via   Efficient Tasking with Composable Data   Partitioning</li> </ul> <p>Zhihao Jia</p> <ul> <li>Stanford, 2020</li> <li>Assistant Professor, CMU</li> <li>Thesis: Automated Discovery of Machine Learning   Optimizations</li> </ul> <p>Jason Koenig</p> <ul> <li>Stanford, 2022</li> <li>Thesis: Invariant Inference via Quantified   Separation</li> </ul> <p>Kihiro Bando</p> <ul> <li>Stanford, 2023</li> <li>Thesis: Towards High-Performance Discontinuous Galerkin Simulations   of Reacting Flows Using   Legion</li> </ul> <p>Sumith Kulal</p> <ul> <li>Stanford, 2023</li> <li>Thesis: Visual Content Creation and Editing via Structural and   Functional   Hierarchies</li> </ul> <p>Wonyeol Lee</p> <ul> <li>Stanford, 2023</li> <li>Assistant Professor, POSTECH</li> <li>Thesis: Reasoning About Floating Point in Real-World   Systems</li> </ul>"},{"location":"research/","title":"Research","text":""},{"location":"research/#research","title":"Research","text":"<p>You are being redirected to the Research Projects section on the Home page.</p> <p>Go to Research </p>"},{"location":"sss/","title":"Stanford Software Seminar","text":""},{"location":"sss/#stanford-software-seminar","title":"Stanford Software Seminar","text":"<p>During the Gates renovation the software seminar is being held irregularly on Zoom. Join the mailing list to get announcements with the links for the presentations.</p> <p>To subscribe to the seminar mailing list, visit its mailman page or send an email to software-research-join@lists.stanford.edu from the email address you wish to subscribe. Likewise, to unsubscribe, send an email to software-research-leave@lists.stanford.edu from the subscribed email address. In either case, the subject and body of your email will be ignored.</p> <p>Date</p> <p>11am Thursday, October 21, 2021</p> <p>Place</p> <p>virtual</p> <p>Speaker</p> <p>George Bosilca, University of Tennessee, Knoxville</p> <p>Title</p> <p>Productivity and Performance: The PaRSEC Task-Based Runtime as an Alternative Programming Paradigm</p> <p>Abstract</p> <p>The PaRSEC project is dedicated to addressing two challenging problems facing the parallel developer community: create an execution model that enables developers to efficiently express all available parallelism in their applications, and ensure this execution model remains flexible and portable enough to actually provide sustained performance on many different hardware ecosystems.</p> <p>The PaRSEC Environment provides a software ecosystem composed of a runtime component to dynamically execute task-based applications on heterogeneous distributed systems, and a productivity toolbox that comprises a development framework for the support of multiple Domain Specific Languages (DSLs) and extensions, with debugging, trace collection, and analysis tools.</p> <p>This talk describes some of PaRSEC's DSL and evaluates them on a set of critical applications.</p> <p>Speaker Bio</p> Date Wednesday, June 5 2019, 10am Place Gates 463a Speaker Armando Solar-Lezama, MIT Title Training machines to program in the third wave of program synthesis Abstract About 14 years ago, advances in formal methods opened the door to a second wave of program synthesis research, which picked up where early efforts in program synthesis in the nineteen eighties had left off. This wave of research led to dramatic improvements in our ability to synthesize non-trivial algorithms, but more importantly, it led to new insights on how to deploy synthesis technology to solve important problems in a number of domains. Despite their success, however, these techniques still have strong limitations in terms of their scalability, and in terms of the effort that is required in order to apply them to a particular domain. In the past three years, the introduction of deep learning into the field has led to a third wave of program synthesis research, where the insights from the second wave are enhanced with machine learning in order to make program synthesis more scalable and easier to deploy. In this talk I will describe some recent results from my group in this direction. In particular, the talk will emphasize some of the ideas from the second wave of program synthesis that have benefitted from the interaction with machine learning. Speaker Bio Armando Solar-Lezama is an associate professor at MIT, where he leads the computer aided programming group. Before joining MIT, he was a graduate student at UC Berkeley where he completed his PhD in 2008. Date Monday, June 5 2017, 3-4pm Place Gates 104 Speaker Adam Chlipala, MIT Title A Case for Integrating Proof Assistants into Daily Programming Abstract Computer proof assistants are IDEs for developing rigorous mathematical proofs that are checked algorithmically. They are just beginning to be accepted as useful for \"real work\" in domains from systems infrastructure to applications. Still, most observers think of a mechanized proof as a kind of penance that programmers can pay to be especially virtuous. Are machine-checked proofs just an extra cost, bolted on to a standard software-development process, to increase assurance? I will argue that, instead, mechanized proofs are a key enabler of new patterns of abstraction and modularity, and these new patterns deserve to permeate the whole life cycle of development. I will draw examples from a few different efforts I'm involved with, applying the Coq proof assistant. One reach target, for the different aspects combined, is to synthesize efficient and secure Internet servers from specifications. Key challenge areas included persistent data management, parsing of network wire formats, and cryptography. I will describe how we are able to generate performance-competitive code automatically from reasonable specifications in each domain -- and how to do it in a way that generates proofs of correctness. The resulting programmer experience is something between \"program synthesis\" and \"programming with well-designed libraries.\" The paradigm we're pushing is code libraries that include specification notations and procedures that know how to compile those notations efficiently, with proofs. Speaker Bio Adam Chlipala has been on the faculty in computer science at MIT since 2011. He did his undergrad at Carnegie Mellon and his PhD at Berkeley. His research focus is applying mechanized logical reasoning to the programming process (both software and hardware) to improve how we implement, compile, specify, verify, and synthesize code. Much of his work uses the Coq proof assistant, about which he has written a popular book, \"Certified Programming with Dependent Types.\" Current projects involve verification and synthesis for processors, file systems, cryptography, databases, and Internet servers. He is designer and implementer of the Ur/Web programming language, a domain-specific functional language for building modern Web applications, which has a few commercial users. Date Monday, May 15 2017, 3:00pm - 4:00pm Place Gates 415 Speaker Yu Feng, UT Austin Title Component-based Synthesis of Table Consolidation and Transformation Tasks from Examples Abstract Programs that manipulate tabular data are extremely important in an era where data analytics has gained enormous popularity. Since raw data is rarely in a form that is immediately amenable to an analytics or visualization task, data scientists typically spend over 80% of their time performing tedious data preparation tasks. Such tasks include consolidating multiple data sources into a single table, reshaping data from one format into another, or adding new rows or columns to an existing table. In this talk, I will present a novel component-based synthesis algorithm that marries the power of type-directed search with lightweight SMT-based deduction and partial evaluation. Given a set of components together with their over-approximate first-order specification, our method first generates a program sketch over a subset of the components and checks its feasibility using an SMT solver. Since a program sketch typically represents many concrete programs, the use of SMT-based deduction greatly increases the scalability of the algorithm. Once a feasible program sketch is found, our algorithm completes the sketch in a bottom-up fashion, using partial evaluation to further increase the power of deduction for rejecting partially-filled program sketches. We apply the proposed synthesis methodology for automating a large class of data preparations tasks that commonly arise in data science. We have evaluated our synthesis algorithm on dozens of data wrangling and consolidation tasks obtained from on-line forums, and we show that our approach can automatically solve a large class of problems encountered by R users. Speaker Bio Yu Feng is a 5th year Ph.D. student at UT Austin advised by Isil Dillig and he was a member of the STAMP group led by Alex Aiken. Yu has interests spanning programming languages, security, and software engineering. For instance, he has published topics about Android Malware Detection (fse'14, ndss'17), Program Synthesis (popl'17, pldi'17) and Program Analysis (oopsla'15, aplas'15). Date Friday, May 12 2017, 2-3pm Place Gates 415 Speaker Loris D'Antoni, University of Wisconsin-Madison Title Adventures in program repair Abstract Programmers constantly face errors that are confusing and hard to fix. In particular, inexperienced programmers, who cannot address commonly occurring errors, have to resort to online help-forums for finding corrections to their buggy programs. I will present three ideas that leverage advances in program synthesis to automatically assist unskilled programmers that face commonly occurring errors. First, I will talk about \"emulative program repair\", a technique for automatically learning how to fix errors directly from programmers. Given examples of bug fixes from real programmers, we synthesize \"rules\" that generalize such bug fixes and use them to automatically repair programs that contains similar bugs. Second, I will talk about \"repair via direct manipulation\", a technique that allows the programmer to express what a repaired program should do by directly manipulating intermediate runtime values of a program. Using the manipulated values, we automatically synthesize programs compliant with the user intent. Third, I will talk about \"program repair under uncertainty\", where program inputs are drawn from a probability distribution. I will show how program that do not satisfy a given probabilistic postcondition can be efficiently repaired by combining techniques from program synthesis and computational learning theory. Speaker Bio Loris D'Antoni is an Assistant Professor in the MadPL (Madison Programming Languages and Software Engineering) Group at the University of Wisconsin-Madison. He received his PhD from the University of Pennsylvania in 2015, where he worked under the supervision of Rajeev Alur. His dissertation \"Programming using Automata and Transducers\" won the The Morris and Dorothy Rubinoff Award. Loris's research interests lie in formal methods and program synthesis, with applications to networking, personalized education, and data science. Loris is currently investigating how formal methods can be used to provide personalized feedback to computer science students, to automatically program networks, and to remove bias from machine learning classifiers. Date Thursday, April 20 2017, 2:00pm - 3:00pm Place Gates 463A Speaker Michael Pradel, Assistant Professor, TU Darmstadt Title Systematic Black-Box Analysis of Collaborative Web Applications Abstract Web applications, such as collaborative editors that allow multiple clients to concurrently interact on a shared resource, are difficult to implement correctly. Existing techniques for analyzing concurrent software do not scale to such complex systems or do not consider multiple interacting clients. This paper presents Simian, the first fully automated technique for systematically analyzing multi-client web applications. Naively exploring all possible interactions between a set of clients of such applications is practically infeasible. Simian obtains scalability for real-world applications by using a two-phase black-box approach. The application code remains unknown to the analysis and is first explored systematically using a single client to infer potential conflicts between client events triggered in a specific context. The second phase synthesizes multi-client interactions targeted at triggering misbehavior that may result from the potential conflicts, and reports an inconsistency if the clients do not converge to a consistent state. We evaluate the analysis on three widely used systems, Google Docs, Firepad, and ownCloud Documents, where it reports a variety of inconsistencies, such as incorrect formatting and misplaced text fragments. Moreover, we find that the two-phase approach runs 10x faster compared to exhaustive exploration, making systematic analysis practically applicable. (Joint work with Marina Billes and Anders Moller. Paper at PLDI'17.) Speaker Bio Michael Pradel is an assistant professor at TU Darmstadt, which he joined after a PhD at ETH Zurich and a post-doc at UC Berkeley. His research interests span software engineering and programming languages, with a focus on tools and techniques for building reliable, efficient, and secure software. In particular, he is interested in dynamic program analysis, test generation, concurrency, performance profiling, and JavaScript-based web applications. Date Monday, March 6 2017, 2:00pm - 3:00pm Place Gates 415 Speaker Thomas Ball, Principal Researcher and Research Manager, Microsoft Research Title Physical Computing for Everyone Abstract Thanks to Moore\u2019s Law, embeddable microcontroller-based devices continue to get cheaper, faster, and include more integrated sensors and networking options. In 2016, the BBC and a host of technical partners, including Microsoft, delivered such a physical computing device, the micro:bit, to every 5th grader in the UK. Microsoft Research helped to make the micro:bit easy to program for novices. The non-profit Micro:bit Education Foundation (microbit.org), of which Microsoft is a founding partner, was recently created to take the micro:bit global. Over the last year, Microsoft has invested in a new web-based programming platform for physical computing, called PXT, with the micro:bit being the first target (pxt.microbit.org). In this talk, I\u2019ll describe the design and implementation of PXT, focusing specifically on its web-based approach to physical computing. PXT supports rapid script development and testing within the confines of a modern web browser, via a novel combination of Blockly, TypeScript and hardware simulation. A browser-based compilation toolchain targets both the Thumb and AVR instruction sets and links against pre-compiled C++ code. PXT uses a bespoke C++ runtime from Lancaster University that provides a set of useful abstractions, including events, a message bus, and fibers. Speaker Bio Thomas (Tom) Ball is a principal researcher and manager at Microsoft Research. In 1999, Tom initiated the SLAM software model-checking project with Sriram Rajamani. This led to the creation of the Static Driver Verifier tool for finding defects in Windows device drivers. Tom is a 2011 ACM Fellow for \u201ccontributions to software analysis and defect detection.\u201d As a manager, he has nurtured research areas such as automated theorem proving, program testing/verification, and empirical software engineering. His current focus is CS education and the PXT platform for physical computing. Date Wednesday, September 21, 4:00pm - 5:00pm Place Gates 104 Speaker Tom Henzinger, IST Austria Title The Quest for Average Response Time Abstract Responsiveness -the requirement that every request to a system be eventually handled- is one of the fundamental liveness properties of a reactive system and lies at the heart of all methods for specifying and verifying liveness. Average response time is a quantitative measure for the responsiveness requirement used commonly in performance evaluation. The static computation of average response time has proved remarkably elusive even for finite-state models of reactive systems. We present, for the first time, a robust formalism that allows the specification and computation of quantitative temporal properties including average response time. The formalism is based on nested weighted automata, which can serve as monitors for measuring the response time of a reactive system. We show that the average response time can be computed in exponential space for nondeterministic finite-state models of reactive systems and in polynomial time for probabilistic finite-state models. This work is joint with Krishnendu Chatterjee and Jan Otop. Date Thursday, January 21, 3:00pm - 4:00pm Place Gates 415 Speaker Julian Shun, UC Berkeley Title A Framework for Processing Large Graphs in Shared Memory Abstract In this talk, I will discuss Ligra, a shared-memory graph processing framework that has two very simple routines, one for mapping over edges and one for mapping over vertices. The routines can be applied to any subset of the vertices, which makes the framework useful for many graph traversal algorithms that operate on subsets of the vertices. Based on recent ideas used in a very fast algorithm for breadth-first search, the routines automatically adapt to the density of vertex sets. Ligra is able to express a broad class of graph algorithms including BFS, betweenness centrality, eccentricity estimation, connectivity, PageRank, and single-source shortest paths. The algorithms expressed using this framework are very simple and concise, and perform almost as well as highly optimized code. Furthermore, they get good speedups on a modern 40-core machine and are sometimes much more efficient than previously reported results using graph frameworks on machines with many more cores. I will also discuss Ligra+, an extension of Ligra that uses graph compression to reduce space usage and improve parallel performance. Speaker Bio Julian Shun (http://www.eecs.berkeley.edu/~jshun) is currently a Miller postdoc at UC Berkeley. He obtained his Ph.D. in Computer Science from Carnegie Mellon University, and his undergraduate degree in Computer Science from UC Berkeley. He is interested in developing large-scale parallel algorithms for graph processing, and parallel text algorithms and data structures. He is also interested in designing methods for writing deterministic parallel programs and benchmarking parallel programs. Date Tuesday, September 22, 11:00am-12:00pm Place Gates 415 Speaker Nate Foster, Cornell University Title NetKAT: Semantic Foundations for Networks Abstract Formal specification and verification of computer networks has become a reality in recent years, with the emergence of domain-specific programming languages and automated verification tools. But the design of these languages and tools has been largely ad hoc, driven more by the needs of applications and the capabilities of hardware than by any foundational principles. This talk will present NetKAT, a language for programming networks based on a well-studied mathematical foundation, Kleene Algebra with Tests (KAT). The first part of the talk will describe the design of the language, including primitives for filtering, modifying, and forwarding packets; operators for combining programs in parallel and in sequence; and a Kleene star operator for iterating programs. The next part of the talk will explore the semantic underpinnings of the language, developing an equational deductive reasoning system as well as a formal connection to finite automata. The third part of the talk will show how NetKAT can be compiled to low-level configurations for network devices. Lastly, I will discuss a recent extension of NetKAT with new features designed to support probabilistic programming. NetKAT is joint work with colleagues at Cornell, Facebook, Inhabited Type, Princeton, Samsung, UCL, and UMass Amherst. Speaker Bio Nate Foster is an Assistant Professor of Computer Science at Cornell University. The goal of his search is developing programming languages and tools for building reliable systems. He received a PhD in Computer Science from the University of Pennsylvania in 2009, an MPhil in History and Philosophy of Science from Cambridge University in 2008, and a BA in Computer Science from Williams College in 2001. His awards include a Sloan Research Fellowship, an NSF CAREER Award, a Most Influential POPL Paper Award, a Tien '72 Teaching Award, a Google Research Award, a Yahoo! Academic Career Enhancement Award, and the Morris and Dorothy Rubinoff Award. Date Friday, June 19, 11:00am-12:00pm Place Gates 415 Speaker Martin Vechev, ETH Zurich Title Machine Learning for Programming Abstract The increased availability of massive codebases (\u201cBig Code\u201d) creates an exciting opportunity for new kinds of programming tools based on probabilistic models. Enabled by these models, tomorrow\u2019s tools will provide probabilistically likely solutions to programming tasks that are difficult or impossible to solve with traditional techniques. I will present a new approach for building such tools based on structured prediction with graphical models, and in particular, conditional random fields. These are powerful machine learning techniques popular in computer vision \u2013 by connecting these techniques to programs, our work enables new applications not previously possible. As an example, I will discuss JSNice (http://jsnice.org), a system that automatically de-minifies JavaScript programs by predicting statistically likely variable names and types. Since its release a year ago, JSNice has become a popular tool in the JavaScript community and is regularly used by thousands of developers worldwide. Speaker Bio Martin Vechev (http://www.srl.inf.ethz.ch/vechev.php) is a tenure-track assistant professor at the Department of Computer Science, ETH Zurich. Previously, he was a Research Staff Member at the IBM T.J. Watson Research Center, New York (2007-2011). He obtained his PhD from Cambridge University in 2008. His research interests are in program analysis, program synthesis, application of machine learning to programming languages, and concurrency. Date Thursday, June 11, 2:00pm-3:00pm Place Gates 104 Speaker Ofri Ziv Title Composing Concurrency Control Abstract Concurrency control poses significant challenges when composing computations over multiple data-structures (objects) with different concurrency-control implementations. We formalize the usually desired requirements (serializability, abort-safety, deadlock-safety, and opacity) as well as stronger versions of these properties that enable composition. We show how to compose synchronization protocols in a way which preserves these properties. Our approach generalizes well-known synchronization protocols (such as two-phase-locking and two-phase-commit) and leads to new synchronization protocols. We apply this theory to show how we can safely compose optimistic and pessimistic concurrency control and demonstrate the practical value of such a composition. For example, we show how we can execute a transaction that accesses two objects, one controlled by an STM and another by locking. Date Thursday, June 4, 1:00pm-2:00pm Place Gates 104 Speaker Mayur Naik, Georgia Tech Title Petablox: Declarative Program Analysis for Big Code Abstract Most software development today leverages the world's massive collection of open source software. There is significant room for program analyses to similarly leverage Big Code, the collective knowledge amassed from analyzing existing programs, to automatically infer or predict salient behaviors and vulnerabilities in new programs. We present Petablox, a framework for automatically synthesizing use-cases of arbitrary declarative program analyses for Big Code tasks such as efficiently finding good abstractions, transferring analysis results across programs, and adapting analyses to user feedback. Despite their diversity, all these tasks entail solving large instances of MaxSAT, the maximum satisfiability problem which comprises a mix of hard (inviolable, logical) constraints and soft (violable, probabilistic) constraints. We describe demand-driven, compositional, and learning-based MaxSAT optimizations in Petablox for scaling these tasks to large code bases. Speaker Bio Mayur Naik is an Assistant Professor in Computer Science at Georgia Tech since 2011. His research interests are in programming languages and software engineering, with a current emphasis on program analysis techniques and systems for improving software quality and programmer productivity on modern computing platforms such as parallel, mobile, and cloud computing. He holds a Ph.D. in Computer Science from Stanford University (2007) and was a research scientist at Intel Labs, Berkeley from 2008 to 2011. Date Friday, May 8, 11:00-12:00 Place Gates 415 Speaker Philip Wadler, University of Edinburgh Title A Practical Theory of Language-Integrated Query Abstract Language-integrated query is receiving renewed attention, in part because of its support through Microsoft's LINQ framework. We present a theory of language-integrated query based on quotation and normalisation of quoted terms. Our technique supports abstraction over values and predicates, composition of queries, dynamic generation of queries, and queries with nested intermediate data. Higher-order features prove useful even for constructing first-order queries. We prove that normalisation always succeeds in translating any query of flat relation type to SQL. We present experimental results confirming our technique works, even in situations where Microsoft's LINQ framework either fails to produce an SQL query or, in one case, produces an avalanche of SQL queries. Date Monday, March 23, 2:00-3:00 Place Gates 415 Speaker Per Stenstr\u00f6m, Chalmers University of Technology, Sweden Title Efficient Statistical-based Cache Compression Abstract Low utilization of on-chip cache capacity limits performance and causes energy wastages because of the long latency, the limited bandwidth, and the energy consumption associated with off-chip memory accesses. Value replication \u00ad- the same value appears in multiple memory locations \u00ad- is an important source of low capacity utilization. While cache compression techniques in the past manage to code frequent values densely, they trade off a high compression ratio for low decompression latency, thus missing opportunities to utilize on-chip cache capacity more effectively. This talk presents, for the first time, a detailed design-space exploration of statistical-based cache compression. We show that more aggressive, statistical-based compression approaches, such as Huffman, that have been excluded in the past due to the processing overhead for compression and decompression, are prime candidates for cache and memory compression. We first find that the overhead of statistics acquisition to generate new codewords is low because value locality varies little over time and across applications so new encodings need to be generated rarely, making it possible to off-load it to software routines. We then show that the high compression ratio obtained by Huffman-based cache compression makes it possible to enjoy the performance benefits of 4X larger last-level caches at a power consumption that is about 50% lower than 4X times larger caches. Date Friday, February 27, 3:00-4:00 Place Gates 104 Speaker Armando Solar-Lezama, MIT Title Making synthesis practical. Are we there yet? Abstract In this talk, I will describe recent advances in our ability to synthesize programs that satisfy a specification, and some of the new applications that have been enabled by these advances. The first part of the talk will focus on the Sketch synthesis system and the algorithms that allow it to scale to challenging synthesis problems. The second part of the talk will focus on applications of synthesis to program optimization, automated tutoring and the development of the synthesizer itself. Speaker Bio Armando Solar-Lezama is an associate professor without tenure at MIT where he leads the Computer Aided Programming Group. His research interests include software synthesis and its applications, as well as high-performance computing, information flow security and probabilistic programming. Date Tuesday, July 22, 3:00-4:00 Place Gates 104 Speaker Martin Monperrus, University of Lille Title On the Search Space of Automatic Software Repair Abstract Automatic software repair consists of fixing software bugs automatically. A fix is a small point in a huge space of all possible program modifications. In this talk, I will talk about the topology of this search space, and how one can exploit it to speed up automatic software repair. The talk is based on content from: <ul> <li>Mining Software Repair Models for Reasoning on the Search Space of Automated Program Fixing (Matias Martinez, Martin Monperrus), In Empirical Software Engineering, Springer, 2013.</li> <li>Do the Fix Ingredients Already Exist? An Empirical Inquiry into the Redundancy Assumptions of Program Repair Approaches (Matias Martinez, Westley Weimer, Martin Monperrus), In Proceedings of the International Conference on Software Engineering, 2014.</li> <li>A Critical Review of \"Automatic Patch Generation Learned from Human-Written Patches\": Essay on the Problem Statement and the Evaluation of Automatic Software Repair (Martin Monperrus), In Proceedings of the International Conference on Software Engineering, 2014.</li> </ul> Speaker Bio The speaker is an Associate Professor at the University of Lille (France) and a member of INRIA's research group SPIRALS. In 2008-2011, he was a research associate at the Darmstadt University of Technology (Germany), and received his Ph.D. from the University of Rennes (France) in 2008. Date Monday, July 21, 3:00-4:00 Place Gates 104 Speaker Emina Torlak, UC Berkeley Title Programming for Everyone: From Solvers to Solver-Aided Languages and Beyond Abstract In this talk, I will present a new approach to constructing programs, which exploits advances in constraint solving to make programming easier for experts and more accessible to everyone else. The approach is based on two observations. First, much of everyday programming involves the use of domain-specific languages (DSLs) that are embedded, in the form of APIs and interpreters, into modern host languages (for example, JavaScript, Scala or Racket). Second, productivity tools based on constraint solvers (such as verification or synthesis) work best when specialized to a given domain. Rosette is a new kind of host language, designed for easy creation of DSLs that are equipped with solver-based tools. These Solver-Aided DSLs (SDSLs) use Rosette's symbolic virtual machine (SVM) to automate hard programming tasks, including verification, debugging, synthesis, and programming with angelic oracles. The SVM works by compiling SDSL programs to logical constraints understood by SMT solvers, and then translating the solver's output to counterexamples (in the case of verification), traces (in the case of angelic execution), or code snippets (in the case of synthesis and debugging). Rosette has hosted several new SDSLs, including imperative SDSLs for data-parallel and spatial programming; a functional SDSL for specifying executable semantics of secure stack machines; and a declarative SDSL for web scraping by example. Speaker Bio Date Thursday, May 29, 2:00-3:00 Place Gates 104 Speaker Atif Memon, University of Maryland Title The First Decade of GUI Ripping: Extensions, Applications, and Broader Impacts Abstract This seminar provides a retrospective examination of GUI Ripping---reverse engineering a workflow model of the graphical user interface of a software application---born a decade ago out of recognition of the severe need for improving the then largely manual state-of-the-practice of functional GUI testing. In these last 10 years, GUI ripping has turned out to be an enabler for much research, both within our group at Maryland and other groups. Researchers have found new and unique applications of GUI ripping, ranging from measuring human performance to re-engineering legacy user interfaces. GUI ripping has also enabled large-scale experimentation involving millions of test cases, thereby helping to understand the nature of GUI faults and characteristics of test cases to detect them. It has resulted in large multi-institutional Government-sponsored research projects on test automation and benchmarking. GUI ripping tools have been ported to many platforms, including Java AWT and Swing, iOS, Android, UNO, Microsoft Windows, and web. In essence, the technology has transformed the way researchers and practitioners think about the nature of GUI testing, no longer considered a manual activity; rather, thanks largely to GUI Ripping, automation has become the primary focus of current GUI testing techniques. Speaker Bio Atif M. Memon is an Associate Professor at the Department of Computer Science, University of Maryland, where he founded and heads the Event Driven Software Lab (EDSL). Researchers at the EDSL study issues of design, development, quality assurance, and maintenance of such software applications. He designed and developed the model-based GUI testing software GUITAR, which operates on Android, iPhone, Java Swing, .NET, Java SWT, UNO, MS Windows, and web systems, and leverages a resource cloud for test automation. He has published over 100 research articles on the topic of event driven systems, software testing, and software engineering. He is the founder of the International Workshop on TESTing Techniques &amp; Experimentation Benchmarks for Event-Driven Software (TESTBEDS). He also helped develop the workshop on Experimental Evaluation of Software and Systems in Computer Science (EVALUATE). <p>He is the Serial Editor of Advances in Computers, published by Elsevier. This series, since its first volume in 1960 and now the oldest series still being published, covers new developments in computer technology. He is an elected member of the Steering Committee of the International Conference on Software Testing, Verification and Validation ICST, the largest conference on software testing. He serves on various editorial boards, including that of the Journal of Software Testing, Verification, and Reliability. He has served on numerous National Science Foundation panels and program committees, including ICSE, FSE, ICST, WWW, ASE, ICSM, and WCRE. He is currently serving on a National Academy of Sciences panel as an expert in the area of Computer Science and Information Technology, for the Pakistan-U.S. Science and Technology Cooperative Program, sponsored by United States Agency for International Development (USAID).</p> <p>He has a joint appointment in the University's Institute for Advanced Computer Studies (UMIACS). He received his Ph.D. from the University of Pittsburgh in Computer Science in 2001, and started at the University of Maryland soon thereafter. In 2007 he was a visiting scholar at the Institute of Software at the Chinese Academy of Sciences, and a visiting researcher at Tata Research Development and Design Centre.</p> Date Thursday, May 15, 4:00-5:00 Place Gates 104 Speaker Adam Chlipala, MIT Title Bedrock: A Platform for Practical Proof-Carrying Code with Rich Policies Abstract Today more than ever, the computing ecosystem is full of examples of execution of untrusted code. From mobile applications, to JavaScript-based Web applications in browsers, to virtual-machine images run by cloud providers, users from consumers to hosting providers are running programs produced by untrusted third parties. It is essential to enforce security policies on these pieces of untrusted code, but the common techniques of today are often too weak, and they often impose high run-time costs in power and so forth, which matter especially much for resource-constrained mobile devices. One alternative paradigm is proof-carrying code (PCC), where developers distribute software with machine-checkable proofs of adherence to policies. In this talk, I will give an overview of Bedrock, a platform to make PCC more practical along a number of dimensions. <p>Ideally we want to apply PCC with rich behavioral policies, but, without careful tool design, it can be intractable to build rigorous conformance proofs for realistic programs. Past PCC frameworks supporting rich policies have required on the order of 100 lines of manual proof per 1 line of assembly code. Bedrock, a library for the Coq proof assistant, brings this ratio closer to 1-to-1. We can do mostly automated assembly-level proofs of functional correctness for tricky program modules that mix features like heap-allocated data structures, function pointers, and concurrency. In this domain, the challenge is not just the algorithmic design of verification tools, but also the generation of machine-checkable proofs from first principles. I will focus on three broad challenges that are important to scale up the approach: \"horizontal\" modularity in the form of program decomposition into modules, \"vertical\" modularity via verified compilers, and effective proof automation for individual program modules written in particular languages.</p> Speaker Bio Adam Chlipala is an assistant professor in computer science at MIT. He completed his PhD in CS at Berkeley in 2007 and his BS in CS at CMU in 2003. His research interests, broadly speaking, are in applied logic for software development tools. Much of his group's work uses the Coq theorem-proving software, about which he has written a popular book \"Certified Programming with Dependent Types.\" Current projects in theorem-proving deal with verification of compilers and low-level imperative code. He also designed the Ur/Web domain-specific programming language for modern Web applications, which applies advanced type system ideas in a form practical enough to be used by several production Web applications. Date Friday March 7, 2:00-3:00 Place Gates 392 Speaker Mooly Sagiv, Tel Aviv University Title VeriCon: Towards Verifying Controller Programs in Software-Defined Networks Abstract Software-defined networking (SDN) is a new paradigm for operating and managing computer networks. SDN enables logically-centralized control over network devices through a software ``controller'' program that operates independently from the network hardware. <p>We present VeriCon, the first system for verifying network-wide invariants of SDN controller programs. VeriCon uses first-order logic to define admissible network topologies and desired network-wide invariants (e.g., routing correctness. correct access control, and consistency of the controller's data structures).</p> <p>VeriCon either confirms the correctness of the controller program on ALL admissible network topologies or outputs a concrete example that violates an invariant, and so can be used for debugging controller code.</p> <p>We show that VeriCon, which implements classical Floyd-Hoare-Dijkstra deductive verification, is practical for a large repertoire of controller programs. In addition, as VeriCon is compositional, in the sense that it checks the correctness of each network event independently against the specified invariants, it can scale to handle complex systems.</p> <p>We view VeriCon as a first step en route to practical mechanisms for verifying network-wide invariants of controller code. This is a joint work with Thomas Ball and Nikolaj Bjorner (MSR), Aaron Gember (Wisc), Shachar Itzhaky (TAU), Aleksandr Karbyshev (TUM), Michael Schapira and Asaf Valdarsky (HUJI)</p> Speaker Bio Date Friday Jan 17, 3-4pm Place Gates 498 Speaker Stavros Aronis, Uppsala University Title Optimal Dynamic Partial Order Reduction Abstract Stateless model checking is a powerful technique for program verification, which however suffers from an exponential growth in the number of explored executions. A successful technique for reducing this number, while still maintaining complete coverage, is Dynamic Partial Order Reduction (DPOR). We present a new DPOR algorithm, which is the first to be provably optimal in that it always explores the minimal number of executions. It is based on a novel class of sets, called source sets, which replace the role of persistent sets in previous algorithms. First, we show how to modify an existing DPOR algorithm to work with source sets, resulting in an efficient and simple to implement algorithm. Second, we extend this algorithm with a novel mechanism, called wakeup trees, that allows to achieve optimality. We have implemented both algorithms in a stateless model checking tool for Erlang programs. Experiments show that source sets significantly increase the performance and that wakeup trees incur only a small overhead in both time and space. Speaker Bio Date 3:00-4:00, Monday, November 18 Place Gates 415 Speaker Junfeng Yang, Columbia University Title Determinism Is Not Enough: Making Parallel Programs Reliable with Stable Multithreading Abstract Our accelerating computational demand and the rise of multicore hardware have made parallel programs, especially shared-memory multithreaded programs, increasingly pervasive and critical. Yet, these programs remain extremely difficult to write, test, analyze, debug, and verify. Conventional wisdom has attributed these difficulties to nondeterminism (i.e., repeated executions of the same program on the same input may show different behaviors), and researchers have recently dedicated much effort to bringing determinism into multithreading. In this talk, I argue that determinism is not as useful as commonly perceived: it is neither sufficient nor necessary for reliability. We present our view on why multithreaded programs are difficult to get right, describe a promising approach we call stable multithreading to dramatically improve reliability, and summarize our last four years research on building and applying stable multithreading systems. (More details are at http://www.cs.columbia.edu/~junfeng/.) Speaker Bio Date 3:00-4:00, Monday, December 2 Place Gates 415 Speaker Todd Millstein, UCLA Title Toward a \"Safe\" Semantics for Multithreaded Programming Languages Abstract \"Safe\" programming languages enforce fundamental language abstractions, thereby providing strong guarantees for all program executions and obviating large classes of subtle and dangerous errors. Modern languages have embraced the compelling programmability benefits of (memory and type) safety despite the additional run-time overhead. Unfortunately, recent work to standardize multithreading semantics in mainstream programming languages is reversing this trend. While a significant improvement over prior informally-specified semantics, the current standards allow a small programming error or omission to violate program safety in ways that are difficult to understand, detect, and correct. <p>In this talk I will argue that a safe multithreaded programming language should support the simple interleaving semantics of threads known as sequential consistency (SC). I'll then describe the results of our research over the past few years, which challenges the idea that the SC semantics is inconsistent with high performance. Perhaps surprisingly, restricting a modern compiler's optimizations to respect SC introduces minimal runtime overhead. While modern hardware relies upon important optimizations that potentially violate SC, a small extension to such hardware can preserve the SC semantics while retaining the lion's share of the benefit of these optimizations. Further, various factors will conspire to lower the cost of SC on stock hardware in the coming years.</p> <p>This work is joint with Dan Marino (Symantec Research Labs, formerly UCLA), Abhay Singh (U Michigan, Ann Arbor), Madan Musuvathi (Microsoft Research, Redmond), and Satish Narayanasamy (U Michigan, Ann Arbor).</p> Speaker Bio Todd Millstein is an Associate Professor in the Computer Science Department at the University of California, Los Angeles. Todd received his Ph.D. and M.S. from the University of Washington and his A.B. from Brown University, all in Computer Science. Todd received an NSF CAREER award in 2006, an IBM Faculty Award in 2008, an ACM SIGPLAN Most Influential PLDI Paper Award in 2011, and an IEEE Micro Top Picks selection in 2012. Date 2:00-3:00, Monday, September 16 Place 104 Gates Speaker Mohsen Lesani, UCLA Title On Testing and Verification of Transactional Memory Algorithms Abstract A transactional memory (TM) is an object composed of a set of base objects such as registers and locks. The safety of the TM algorithm is the result of the safety of the composed base objects and the logic of the algorithm. We define a language that captures the type of the base objects and the algorithm. We define a history semantics for the language that characterizes the set of histories that a program can result. Based on the history semantics, we propose techniques for both testing and verification of TM algorithms. First, we identify two problems that lead to violation of opacity, a safety criterion for TM. We present an automatic tool that given a violating history, finds program traces that result in that history. We show that the well-known TM algorithms DSTM and McRT don't satisfy opacity. DSTM suffers from a write-skew anomaly, while McRT suffers from a write-exposure anomaly. Second, we present a program logic with novel propositions about execution order and linearization orders of base objects. We prove that our inference rules are sound i.e. if we can derive that a program satisfies a property, then every history of the program satisfies the property. Our logic is composable as it can be augmented with new inference rules to support reasoning about new object types. We have used our logic to prove that TL2 TM algorithm satisfies opacity. We are formalizing our logic and proofs in PVS. Speaker Bio Mohsen Lesani is a Phd candidate at UCLA advised by professor Palsberg. He has research experience with IBM Research, Oracle (Sun) Labs, HP Labs and EPFL. He is interested in the design, implementation, testing and verification of synchronization algorithms. Date 4:00-5:00, Tuesday, May 28 Place 415 Gates Speaker Vijay Ganesh Title SMT Solvers for Software Reliability and Security Abstract SMT solvers increasingly play a central role in the construction of reliable and secure software, regardless of whether such reliability/security is ensured through formal methods, program analysis or testing. This dramatic influence of SMT solvers on software engineering as a discipline is a recent phenomenon, largely attributable to impressive gains in solver efficiency and expressive power. <p>In my talk, I will motivate the need for SMT solvers, sketch out their research story thus far, and then describe my contributions to solver research. Specifically, I will talk about two SMT solvers that I designed and implemented, namely, STP and HAMPI, currently being used in 100+ research projects. I will talk about real-world applications enabled by my solvers, and the techniques I developed that helped make them efficient.</p> <p>Time permitting, I will also talk about some theoretical results in the context of SMT solving.</p> Speaker Bio Vijay Ganesh is an assistant professor at the University of Waterloo, Canada, since September 2012. Prior to that he was a Research Scientist at MIT, and completed his PhD in computer science from Stanford University. Date 2:00-3:00, Monday, May 20 Place Gates 104 Speaker Cristian Cadar, Imperial College London Title Safe Software Updates via Multi-version Execution Abstract Software systems are constantly evolving, with new versions and patches being released on a continuous basis. Unfortunately, software updates present a high risk, with many releases introducing new bugs and security vulnerabilities. We tackle this problem using a simple but effective multi-version based approach. Whenever a new update becomes available, instead of upgrading the software to the new version, we run the new version in parallel with the old one; by carefully coordinating their executions and selecting the behavior of the more reliable version when they diverge, we create a more secure and dependable multi-version application. We implemented this technique in Mx, a system targeting Linux applications running on multi-core processors, and show that it can be applied successfully to several real applications, such as Lighttpd and Redis. Date 3:00-4:00, Monday, May 6 Place Gates 392 Speaker Rupak Majumdar, Max Planck Institute Title Static Provenance Verification for Message-Passing Programs Abstract Provenance information records the source and ownership history of an object. We study the problem of static provenance tracking in concurrent programs in which several principals execute concurrent processes and exchange messages over unbounded but unordered channels. The provenance of a message, roughly, is a function of the sequence of principals that have transmitted the message in the past. The provenance verification problem is to statically decide, given a message passing program and a set of allowed provenances, whether the provenance of all messages in all possible program executions, belongs to the allowed set. We formalize the provenance verification problem abstractly in terms of well-structured provenance domains, and show a general decidability result for it. In particular, we show that if the provenance of a message is a sequence of principals who have sent the message, and a provenance query asks if the provenance lies in a regular set, the problem is decidable and EXPSPACE-complete. We describe an implementation of our technique to check provenances of messages in Firefox extensions. (Joint work with Roland Meyer and Zilong Wang) Speaker Bio Date 2:30-3:30, Thurs., Dec. 6 Place 392 Gates Speaker Christoph Kirsch, University of Salzburg Title Distributed Queues: Faster Pools and Better Queues Abstract Designing and implementing high-performance concurrent data structures whose access performance scales on multicore hardware is difficult. An emerging remedy to scalability issues is to relax the sequential semantics of the data structure and exploit the resulting potential for parallel access in relaxed implementations. However, a major obstacle in the adoption of relaxed implementations is the belief that their behavior becomes unpredictable. We therefore aim at relaxing existing implementations systematically for better scalability and performance without incurring a cost in predictability. We present distributed queues (DQ), a new family of relaxed concurrent queue implementations. DQ implement bounded or unbounded out-of-order relaxed queues with strict (i.e. linearizable) emptiness check. Our comparison of DQ against existing pool, and strict and relaxed queue implementations reveals that DQ outperform and outscale the state-of-the-art implementations. We also empirically show that the shorter execution time of queue operations of fast but relaxed implementations such as DQ (i.e. the degree of reordering through overlapping operations) may offset the effect of semantical relaxations (i.e. the degree of reordering through relaxation) making them appear as behaving as or sometimes even more FIFO than strict but slow implementations. <p>This is joint work with A. Haas, T.A. Henzinger, M. Lippautz, H. Payer, A. Sezgin, and A. Sokolova</p> Speaker Bio Christoph Kirsch is full professor and holds a chair at the Department of Computer Sciences of the University of Salzburg, Austria. Since 2008 he is also a visiting scholar at the Department of Civil and Environmental Engineering of the University of California, Berkeley. He received his Dr.Ing. degree from Saarland University, Saarbruecken, Germany, in 1999 while at the Max Planck Institute for Computer Science. From 1999 to 2004 he worked as Postdoctoral Researcher at the Department of Electrical Engineering and Computer Sciences of the University of California, Berkeley. His research interests are in concurrent programming and systems, virtual execution environments, and embedded software. Dr. Kirsch co-invented the Giotto and HTL languages, and leads the JAviator UAV project for which he received an IBM faculty award in 2007. He co-founded the International Conference on Embedded Software (EMSOFT), has been elected ACM SIGBED chair in 2011, and is currently associate editor of ACM TODAES. Date 2:00-3:00, July 16, 2012 Place Gates 260 Speaker Jesse Tov, Harvard Title Practical Programming with Substructural Types Abstract Substructural logics remove from classical logic rules for reordering, duplication, or dropping of assumptions. Because propositions in such a logic may no longer be freely copied or ignored, this suggests understanding propositions in substructural logics as representing resources rather than truth. For the programming language designer, substructural logics thus provide a framework for considering type systems that can track the changing states of logical and physical resources. <p>While several substructural type systems have been proposed and implemented, many of these have targeted substructural types at a particular purpose, rather than offering them as a general facility. The more general substructural type systems have been theoretical in nature and too unwieldy for practical use. This talk presents the design of a general purpose language with substructural types, and discusses several language design problems that had to be solved in order to make substructural types useful in practice.</p> Speaker Bio Date 2:00-3:00, July 18, 2012 Place Gates 260 Speaker Aditya Thakur, U. Wisconsin Title A Deductive Algorithm for Symbolic Abstraction with Applications to SMT Abstract This talk presents connections between logic and abstract interpretation. In particular, I will present a new algorithm for the problem of \"symbolic abstraction\": Given a formula \\phi in a logic L and an abstract domain A, the symbolic abstraction of \\phi is the best abstract value in A that over-approximates the meaning of \\phi. When \\phi represents a concrete transformer, algorithms for symbolic abstraction can be used to automatically synthesize the corresponding abstract transformer. Furthermore, if the symbolic abstraction of \\phi is bottom, then \\phi is proved unsatisfiable. <p>The bottom line is that our algorithm is \"dual-use\": (i) it can be used by an abstract interpreter to compute abstract transformers, and (ii) it can be used in an SMT (Satisfiability Modulo Theories) solver to determine whether a formula is satisfiable.</p> <p>The key insight behind the algorithm is that Staalmarck's method for satisfiability checking of propositional-logic formulas can be explained using concepts from the field of abstract interpretation. This insight then led to the discovery of the connection between Staalmarck's method and symbolic abstraction, and the extension of Staalmarck's method to richer logics, such as quantifier-free linear real arithmetic.</p> <p>This is joint work with Prof. Thomas Reps.</p> Speaker Bio Date 3:00-4:00, May 24, 2012 Place Gates 260 Speaker Nataliya Guts, University of Maryland Title Polymonads: Reasoning and Inference Abstract Many useful programming constructions can be expressed as monads. Examples include probabilistic modeling, functional reactive programming, parsing, and information flow tracking, not to mention effectful functionality like state and I/O. In our previous work[SGLH11], we presented a type-based rewriting algorithm to make programming with arbitrary monads as easy as ubuilt-in support for state and I/O. Developers write programs using monadic values of type m t as if they were of type t, and our algorithm inserts the necessary binds, units, and monad-to-monad morphisms so that the program typechecks. <p>A number of other programming idioms resemble monads but deviate from the standard monad binding mechanism. Examples include parameterized monads, monads for effects, information flow state tracking. Our present work aims to provide support for formal reasoning and lightweight programming for such constructs. We present a new expressive paradigm, polymonads, including the equivalent of monad and morphism laws. Polymonads subsume conventional monads and all other examples mentioned above. On the practical side, we provide an extension of our type inference rewriting algorithm to support lightweight programming with polymonads.</p> <p>[SGLH11] N. Swamy, N. Guts, D. Leijen, M. Hicks. Lightweight Monadic Programming in ML. In ICFP, 2011.</p> Speaker Bio Date 3:00-4:00, November 7, 2011 Place Gates 260 Speaker Anupam Datta, CMU Title Policy Auditing over Incomplete Logs Abstract We present the design, implementation and evaluation of an algorithm that checks audit logs for compliance with privacy and security policies. The algorithm, which we name reduce, addresses two fundamental challenges in compliance checking that arise in practice. First, in order to be applicable to realistic policies, reduce operates on policies expressed in a first-order logic that allows restricted quantification over infinite domains. We build on ideas from logic programming to identify the restricted form of quantified formulas. The resulting logic is more expressive than prior logics used for compliance-checking, including propositional temporal logics and metric first-order temporal logic, and, in contrast to these logics, can express all 84 disclosure-related clauses in the HIPAA Privacy Rule. Second, since audit logs are inherently incomplete (they may not contain sufficient information to determine whether a policy is violated or not), reduce proceeds iteratively: in each iteration, it provably checks as much of the policy as possible over the current log and outputs a residual policy that can only be checked when the log is extended with additional information. We prove correctness, termination, time and space complexity results for reduce.We implement reduce and evaluate it by checking simulated audit logs for compliance with the HIPAA Privacy Rule. Our experimental results demonstrate that the algorithm is fast enough to be used in practice. Speaker Bio Anupam Datta is an Assistant Research Professor at Carnegie Mellon University where he is affiliated with CyLab, the Electrical and Computer Engineering Department, and (by courtesy) the Computer research focuses on foundations of security and privacy. One area of focus has been on programming language methods for compositional security. His work on Protocol Composition Logic and the Logic of Secure Systems has uncovered new principles for compositional security and has been applied successfully to find attacks in and verify properties of a number of practical cryptographic protocols and secure systems. A second area of focus has been on formalizing and enforcing privacy policies. He has worked on a Logic of Privacy that formalizes concepts from contextual integrity --- a philosophical theory of privacy as a right to appropriate flows of personal information. His group has produced the first complete formalization of the HIPAA Privacy Rule using this logic and developed principled audit mechanisms for enforcing policies expressed in the logic. <p>Dr. Datta has co-authored a book and over 30 publications in conferences and journals on these topics. He serves on the Steering Committee of the IEEE Computer Security Foundations Symposium. He has served as Program Co-Chair of the 2011 Formal Aspects of Security and Trust Workshop and the 2008 Formal and Computational Cryptography Workshop. Dr. Datta obtained MS and PhD degrees from Stanford University and a BTech from IIT Kharagpur, all in Computer Science.</p> Date 3:00-4:00, Oct 4, 2011 Place 498 Gates Speaker David Basin, ETH Zurich Title Policy Monitoring in First-order Temporal Logic Abstract In security and compliance, it is often necessary to ensure that agents and systems comply to complex policies. An example from financial reporting is the requirement that every transaction t of a customer c, who has within the last 30 days been involved in a suspicious transaction t', must be reported as suspicious within 2 days. We present an approach to monitoring such policies formulated in an expressive fragment of metric first-order temporal logic. We also report on case studies in security and compliance monitoring and use these to evaluate both the suitability of this fragment for expressing complex, realistic policies and the efficiency of our monitoring algorithm. Speaker Bio David Basin is a full professor and has the chair for Information Security at the Department of Computer Science, ETH Zurich since 2003. He is also the director of the ZISC, the Zurich Information Security Center. <p>He received his bachelors degree in mathematics from Reed College in 1984, his Ph.D. from Cornell University in 1989, and his Habilitation from the University of Saarbr|cken in 1996. His appointments include a postdoctoral research position at the University of Edinburgh (1990 - 1991), and afterwards he led a subgroup, within the programming logics research group, at the Max-Planck-Institut f|r Informatik (1992 - 1997). From 1997 - 2002 he was a full professor at the University of Freiburg where he held the chair for software engineering.</p> <p>His research focuses on information security, in particular methods and tools for modeling, building, and validating secure and reliable systems.</p> Date 3:00-4:00 pm, June 10 Place Gates 104 Speaker Koushik Sen, UC Berkeley Title Specifying and Checking Correctness of Parallel Programs Abstract The spread of multicore processors and manycore graphics processing units has greatly increased the need for parallel correctness tools. Reasoning about parallel multi-threaded programs is significantly more difficult than for sequential programs due to non-determinism. We believe that the only way to tackle this complexity is to separate reasoning about parallelism correctness (i.e., that a parallel program gives the same outcome despite thread interleavings) from reasoning about functional correctness (i.e., that the program produces the correct outcome on a thread interleaving). In this talk, I will describe two fundamental techniques for separating the parallelization correctness aspect of a program from its functional correctness. The first idea consists of extending programming languages with constructs for writing specifications, called bridge assertions, that focus on relating outcomes of two parallel executions differing only in thread-interleavings. The second idea consists of allowing a programmer to use a non-deterministic sequential program as the specification of a parallel one. For functional correctness, it is then enough to check the sequential program. For parallelization correctness, it is sufficient to check the deterministic behavior of the parallel program with respect to the non-deterministic sequential program. To check parallel correctness, we have developed a new scalable automated method for testing and debugging, called active testing. Active testing combines the power of imprecise program analysis with the precision of software testing to quickly discover concurrency bugs and to reproduce discovered bugs on demand. Speaker Bio Koushik Sen is an assistant professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. His research interest lies in Software Engineering, Programming Languages, and Formal methods. He is interested in developing software tools and methodologies that improve programmer productivity and software quality. He is best known for his work on directed automated random testing and concolic testing. He has received a NSF CAREER Award in 2008, a Haifa Verification Conference (HVC) Award in 2009, a IFIP TC2 Manfred Paul Award for Excellence in Software: Theory and Practice in 2010, and a Sloan Foundation Fellowship in 2011. He has won three ACM SIGSOFT Distinguished Paper Awards. He received the C.L. and Jane W-S. Liu Award in 2004, the C. W. Gear Outstanding Graduate Award in 2005, and the David J. Kuck Outstanding Ph.D. Thesis Award in 2007 from the UIUC Department of Computer Science. He holds a B.Tech from Indian Institute of Technology, Kanpur, and M.S. and Ph.D. in CS from University of Illinois at Urbana-Champaign. Date 1:00-2:00, Friday June 3 Place 463a Gates Speaker Andreas Zeller, Saarland University Title Mining Precise Specifications Abstract Recent advances in software validation and verification make it possible to widely automate the check whether a specification is satisfied. This progress is hampered, though, by the persistent difficulty of writing specifications. Are we facing a \"specification crisis\"? By mining specifications from existing systems, we can alleviate this burden, reusing and extending the knowledge of 60 years of programming, and bridging the gap between formal methods and real-world software. But mining specifications has its challenges: We need good usage examples to learn expected behavior; we need to cope with the approximations of static and dynamic analysis; and we need specifications that are readable and relevant to users. In this talk, I present the state of the art in specification mining, its challenges, and its potential, up to a vision of seamless integration of specification and programming. Speaker Bio Andreas Zeller is a full professor for Software Engineering at Saarland University in Saarbr|cken, Germany. His research concerns the analysis of large software systems and their development process; his students are funded by companies like Google, Microsoft, or SAP. In June 2011, Zeller will be inducted as Fellow of the ACM for his contributions to automated debugging and mining software archives. Date 2:00-3:00, Monday, Feb. 7 Place Gates 104 Speaker Michael Franz, UC Irvine Title Recent Advances In Compiler Research - Firefox's TraceMonkey and Beyond Abstract Common to practically all compilers built over the past 50 years has been the concept of the \"control flow graph\", a model of a program that a compiler builds and then traverses while generating target code. Even just-in-time and embedded compilers use such control flow graphs, although they tend to make the unit of compilation smaller than traditional batch compilers (e.g., one method at a time rather than one class at a time). Trace Compilation, to which we have made significant contributions, represents a radical departure from this long established convention. A novel intermediate representation, the Trace Tree, is constructed lazily on-demand while the program is simultaneously executed, incrementally compiled, and optimized. The advantage of this technique is that the compiler doesn't expend any resources on parts of the program that are not frequently executed; traditional compilers construct control-flow graphs for unimportant and even for unreachable parts of a program and need to prune such graphs later. Our specific approach to trace compilation is now in the process of being adopted widely across and beyond academia. Working with the Mozilla foundation, we incorporated our technique into the Firefox browser, starting with version 3.5. By incorporating our invention, Mozilla was able to raise Firefox's JavaScript performance by a surprising factor of 7. Our Trace Compilation technique is now being used daily by several hundred million users around the globe. Other groups of researchers that are now using trace compilation include Oracle, Adobe, Google, and Microsoft, and we are collaborating with several of these projects. In a second project, we are investigating compiler-generated software diversity as a defense mechanism against software attacks. Our solution is centered on an \"App Store\" containing a diversification engine (a \"multicompiler\") that automatically generates a unique version of every program each time that a downloader requests it. All the different versions of the same program behave in exactly the same way from the perspective of the end-user, but they implement their functionality in subtly different ways. As a result, any specific attack will succeed only on a small fraction of targets. An attacker would require a large number of different attacks and would have no way of knowing a priori which specific attack will succeed on which specific target. Equally importantly, our approach makes it much more difficult for an attacker to generate attack vectors by way of reverse engineering of security patches. Speaker Bio Prof. Michael Franz is a Professor of Computer Science in UCI's Donald Bren School of Information and Computer Sciences, a Professor of Electrical Engineering and Computer Science (by courtesy) in UCI's Henry Samueli School of Engineering, and the director of UCI's Secure Systems and Software Laboratory. He is currently also a visiting Professor of Informatics at ETH Zurich, the Swiss Federal Institute of Technology, from which he previously received the Dr. sc. techn. (advisor: Niklaus Wirth) and the Dipl. Informatik-Ing. ETH degrees. Date 11:00-12:00, Tuesday, December 7th Place Gates 463a Speaker Hongseok Yang, University of London Title Automatic Program Analysis of Overlaid Data Structures Abstract We call a data structure overlaid, if a node in the structure includes links for multiple data structures and these links are intended to be used at the same time. These overlaid data structures are frequently used in systems code, when implementing multiple types of indexing structures over the same set of nodes. For instance, the deadline IO scheduler of Linux has a queue whose node has links for a doubly-linked list as well as those for a red-black tree. The doubly-linked list here is used to record the order that nodes are inserted in the queue, and the red-black tree provides an efficient indexing structure on the sector fields of the nodes. <p>In this talk, I will describe an automatic program analysis of these overlaid data structures. The focus of the talk will be on two main issues: to represent such data structures effectively and to build an efficient yet precise program analyser, which can prove the memory safety of realistic examples, such as the Linux deadline IO scheduler. During the talk, I will explain how we addressed the first issue by the combination of standard classical conjunction and separating conjunction from separation logic. Also, I will describe how we used a meta-analysis and the dynamic insertion of ghost instructions in solving the second issue. If time permits, I will give a demo of the tool.</p> <p>This is a joint work with Oukseh Lee and Rasmus Petersen.</p> Speaker Bio Date 2:00-3:00, October 25 Place Gates 104 Speaker Patrick Eugster, Purdue Title Distributed Event-based Programming in Java Abstract The abstraction of \"event\" has been used for years to reason about concurrent and distributed programs, and is being increasingly used as a programming paradigm. Developing distributed event-based applications is currently challenging for programmers though as it involves integrating a number of technologies besides dealing with an abstraction that cuts across more traditional programming paradigms. <p>EventJava is an extension of the mainstream Java language targeting at simplifying the development of a wide range of event-based applications. In this talk, we first provide an overview of select features of the EventJava language framework and its implementation. Then we present a performance evaluation from different viewpoints. We conclude with an outlook on future work.</p> Speaker Bio Date 1:00-2:00, Wednesday, October 13 Place Gates 219 Speaker Erik Meijer, Microsoft Title Fundamentalist Functional Programming Abstract In 1984, John Hughes wrote a seminal paper titled \"Why Functional Programming Matters\", in which he eloquently explained the value of pure and lazy functional programming. Due to the increasing importance of the Web and the advent of many-core machines, in the quarter of a century since the paper was written, the problems associated with imperative languages and their side effects have become increasingly evident. <p>This talk argues that fundamentalist functional programming-that is, radically eliminating all side effects from programming languages, including strict evaluation-is what it takes to conquer the concurrency and parallelism dragon. Programmers must embrace pure, lazy functional programmin g-with all effects apparent in the type system of the host language using monads.</p> <p>A radical paradigm shift is the answer, but does that mean that all current programmers will be lost along the way? Fortunately not! By design, LINQ is based on monadic principles, and the success of LINQ proves that the world does not fear the monads.</p> Speaker Bio Erik Meijer is an accomplished programming-language designer who has worked on a wide range of languages, including Haskell, Mondrian, X#, C#, and Visual Basic. He runs the Cloud Languages Team in the Business Platform Division at Microsoft, where his primary focus has been to remove the impedance mismatch between databases and programming languages in the context of the Cloud. One of the fruits of these efforts is LINQ, which not only adds a native querying syntax to .NET languages, such as C# and Visual Basic, but also allows developers to query data sources other than tables, such as objects or XML. Most recently, Erik has been working on and preaching the virtues of fundamentalist functional programming in the new age of concurrency and many-core. Some people might recognize him from his brief stint as the \"Head in the Box\" on Microsoft VBTV. These days, you can regularly watch Erik's interviews on the \"Expert to Expert\" and \"Going Deep\" series on Channel 9. Date 2:00-3:00, September 27 Place Gates 104 Speaker Sorin Lerner, UC San Diego Title Strategies for Building Correct Optimizations Abstract Program analyses and optimizations are at the core of many optimizing compilers, and their correctness in this setting is critically important because it affects the correctness of any code that is compiled. However, designing correct analyses and optimizations is difficult, error prone and time consuming. This talk will present several inter-related approaches for building correct analyses and optimizations. I will start with an approach based on a domain-specific language for expressing optimizations, combined with a checker for verifying the correctness of optimizations written in this language. This first approach still requires the programmer to write down the optimizations in full detail. I will then move on to several techniques which instead attempt to synthesize correct optimizations from a higher-level description. In particular, I will present an approach that discovers correct optimization opportunities by exploring the application of equality axioms on the program being optimized. Finally, I will present a technique that synthesizes generally applicable and correct optimization rules from concrete examples of code before and after some transformations have been performed. Speaker Bio Sorin Lerner is an Assistant Professor in the Department of Computer Science and Engineering at the University of California, San Diego. He received his PhD in 2006 from the University of Washington, under the supervision of Craig Chambers. Before that, he received an undergraduate degree in Computer Engineering from McGill University, Montreal. His research interests lie in programming language and analysis techniques for making software systems easier to write, maintain and understand, including static program analysis, domain specific languages, compilation, formal methods and automated theorem proving. Lerner works actively at the interface of Programming Languages and Software Engineering, and frequently publishes at POPL/PLDI and ICSE/FSE. Sorin Lerner was the co-chair of the 2010 ACM SIGPLAN-SIGSOFT PASTE workshop, and is the recipient of an NSF Career Award (2007), and of the 2003 PLDI Best paper award. Date 2:00-3:00, Wednesday, September 15 Place Gates 392 Speaker Madan Musuvathy, Microsoft Research Title A Probabilistic Algorithm for Finding Concurrency Errors (or How to Crash Your Program in the First Few Runs) Abstract Unexpected thread interleavings can lead to concurrency errors that are hard to find, reproduce, and debug. In this talk, I will present a probabilistic algorithm for finding such errors. The algorithm works by randomly perturbing the timing of threads and event handlers at runtime. Every run of the algorithm finds every concurrency bug in the program with some (reasonably large) probability. Repeated runs can be used to reduce the chance of missing bugs to any desired amount. The algorithms scales to large programs and, in many cases, finds bugs in the first few runs of a program. A tool implementing this algorithm is being used to improve the concurrency testing at Microsoft for over a year. <p>I will also describe the relationship between this algorithm and the dimension theory of partial-orders, and how results from this field can be used to further improve the algorithm.</p> Speaker Bio Madan Musuvathi is a researcher at Microsoft Research interested in software verification, program analysis, and systems. Recently, he has focused on the scalable analysis of concurrent systems. He received his Ph.D. at Stanford University in 2004 and has been at Microsoft Research since. Date 1:00-2:00, August 24 Place Gates 104 Speaker Noam Rinetzky, Queen Mary University of London Title Verifying Linearizability with Hindsight Abstract We present a proof of safety and linearizability of a highly-concurrent optimistic set algorithm. The key step in our proof is the Hindsight Lemma, which allows a thread to infer the existence of a global state in which its operation can be linearized based on limited local atomic observations about the shared state. The Hindsight Lemma allows us to avoid one of the most complex and non-intuitive steps in reasoning about highly concurrent algorithms: considering the linearization point of an operation to be in a different thread than the one executing it. <p>The Hindsight Lemma assumes that the algorithm maintains certain simple invariants which are resilient to interference, and which can themselves be verified using purely thread-local proofs. As a consequence, the lemma allows us to unlock a perhaps-surprising intuition: a high degree of interference makes non-trivial highly-concurrent algorithms in some cases much easier to verify than less concurrent ones.</p> <p>Joint work with Peter W. O'Hearn (Queen Mary University of London), Martin T. Vechev (IBM T.J. Watson Research Center), Eran Yahav (IBM T.J. Watson Research Center), and Greta Yorsh (IBM T.J. Watson Research Center).</p> <p>Presented in the 29th Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing (PODC'10).</p> <p>Link to paper: http://www.eecs.qmul.ac.uk/~maon/pubs/PODC10-hindsight.pdf</p> Speaker Bio Date 2:00-3:00, Monday, August 16 Place Gates 104 Speaker Greta Yorsh, IBM Research Title Specializing Memory Management for Concurrent Data Structures Abstract Memory reclamation plays a central role in the design of concurrent data structures. The main challenge is to equip a particular concurrent data structure with its own custom memory reclamation, in a way that is both correct and efficient. This problem arises frequently in environments that do not support automatic memory management, but it is also relevant in the case where we want to obtain a more efficient concurrent data structure. Unfortunately, despite various proposals, the most prevalent methodologies today such as hazard pointers are not well understood, and applying them is still an ad-hoc, error-prone, difficult, and time-consuming manual process. <p>We propose a systematic approach to specialization of memory reclamation to a particular concurrent data structure. We start with a concurrent algorithm that is proven to behave correctly assuming automatic memory reclamation. We apply a sequence of correctness-preserving transformations to both the memory reclamation scheme and the algorithm. These transformation rely on invariants of the algorithm, computed by standard analyses and clearly illustrate why a given transformation is applied and what are the conditions under which it can be applied safely. We demonstrate our approach by systematically deriving correct and efficient custom memory reclamation for state-of-the-art concurrent data structure algorithms, including several variations of concurrent stack, queue, and set algorithms.</p> <p>(joint work in progress with Martin Vechev and Eran Yahav)</p> Speaker Bio Date CHANGED: 1:00-2:00 Friday, August 6 Place CHANGED: Gates 463a Speaker Cindy Rubio Gonzalez, University of Wisconsin Title Error Propagation Analysis for File Systems Abstract Unchecked errors are especially pernicious in operating system file management code. Transient or permanent hardware failures are inevitable, and error-management bugs at the file system layer can cause silent, unrecoverable data corruption. Furthermore, even when developers have the best of intentions, inaccurate documentation can mislead programmers and cause software to fail in unexpected ways. <p>We propose an interprocedural static analysis that tracks errors as they propagate through file system code. Our implementation detects overwritten, out-of-scope, and unsaved unchecked errors. Analysis of four widely-used Linux file system implementations (CIFS, ext3, IBM JFS and ReiserFS), a relatively new file system implementation (ext4), and shared virtual file system (VFS) code uncovers 312 confirmed error propagation bugs. Our flow- and context-sensitive approach produces more precise results than related techniques while providing better diagnostic information, including possible execution paths that demonstrate each bug found.</p> <p>Additionally, we use our error-propagation analysis framework to identify the error codes returned by system calls across 52 Linux file systems. We examine mismatches between documented and actual error codes returned by 42 Linux file-related system calls. Comparing analysis results with Linux manual pages reveals over 1,700 undocumented error-code instances affecting all file systems and system calls examined.</p> Speaker Bio Date 2:00-3:00, Thursday, July 22 Place Gates 104 Speaker Byron Cook, Microsoft Research, Cambridge Title New methods for proving temporal properties of infinite-state systems Abstract I will describe some new methods of proving temporal properties of infinite-state programs. Our approach takes advantage of the fact that linear-temporal properties can often be proved more efficiently using proof techniques usually associated with the branching-time logic CTL. The caveat is that, in certain instances, nondeterminism in the system's transition relation can cause CTL methods to report counterexamples that are spurious in LTL. To address this problem we describe an algorithm that, as it attempts to apply CTL proof methods, finds and then removes problematic nondeterminism via an analysis on the spurious counterexamples. We must also develop CTL symbolic model checking tools for infinite-state systems. Speaker Bio Dr. Byron Cook is a Principal Researcher at Microsoft Research in Cambridge, UK as well as Professor of Computer Science at Queen Mary, University of London. He is one of the developers of the Terminator program termination proving tool, as well as the SLAM software model checker. Before joining Microsoft Research he was a developer in the Windows OS kernel group. See research.microsoft.com/~bycook/ for more information. Date 1:30-2:30, Tuesday, June 1 Place 463a Speaker Sanjit Seshia, UC Berkeley Title Integrating Induction and Deduction for Verification and Synthesis Abstract Even with impressive advances in formal methods over the last few decades, some problems in automatic verification and synthesis remain challenging. Examples include the verification of quantitative properties of software such as execution time, and certain program synthesis problems. In this talk, I will present a new approach to automatic verification and synthesis based on a combination of inductive methods (learning from examples), and deductive methods (based on logical inference and constraint solving). <p>Our approach integrates verification techniques such as satisfiability solving and theorem proving (SAT/SMT), numerical simulation, and fixpoint computation with inductive inference methods including game-theoretic online learning, learning Boolean functions and learning polyhedra. My talk will illustrate this combination of inductive and deductive reasoning for three problems: (i) program synthesis applied to malware deobfuscation; (ii) the verification of execution time properties of embedded software, and (briefly) (iii) the synthesis of switching logic for hybrid systems.</p> Speaker Bio Sanjit A. Seshia is an assistant professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. He received an M.S. and a Ph.D. in Computer Science from Carnegie Mellon University, and a B.Tech. in Computer Science and Engineering from the Indian Institute of Technology, Bombay. His research interests are in dependable computing and computational logic, with a current focus on applying automated formal methods to problems in embedded systems, computer security, and electronic design automation. He has received a Presidential Early Career Award for Scientists and Engineers (PECASE), an Alfred P. Sloan Research Fellowship, and the School of Computer Science Distinguished Dissertation Award at Carnegie Mellon University. Date 2:00-3:00, Tuesday, May 11th Place Gates 104 Speaker Mark Wegman, IBM Research Title Managing Businesses that Design Abstract Software development is fundamentally a design process. The quality of the eventual outcome depends on how well people can come together to create a pleasing design. Different organizations may be vastly better or worse than others in how they create designs. Understanding how what an organization does well is similar in many ways to debugging a program. You instrument it, subject to concerns about privacy. The instrumentation can be done via the tools that we use to build software as that's what people use in the organization. Given the needs of the organization to change, those tools may also need to change. The analysis they do on the Software artifacts may change as well. This is new work in an attempt to define a vision of a potential new science on the management of design. It should be noted that we are not advocating that the best management is more intrusive management -- sometimes the best management recognizes that to accomplish what is needed people need to take more risks up front. Speaker Bio Date 1:30-2:30, Wednesday, May 12 Place Gates 104 Speaker John Field, IBM Research Title The Thorn Programming Language: Robust Distributed Scripting Abstract Scripting languages enjoy great popularity due to their support for rapid and exploratory development. They typically have lightweight syntax, weak data privacy, dynamic typing, and powerful aggregate data types. The price of these features comes later in the software life cycle. Scripts are hard to evolve and compose, and often slow. An additional weakness of m"},{"location":"students/","title":"Current Students","text":""},{"location":"students/#current-students","title":"Current Students","text":"<p>You are being redirected to the Current Ph.D. and Postdoctoral Students section on the Home page.</p> <p>Go to Current Students </p>"},{"location":"teaching/","title":"Teaching","text":""},{"location":"teaching/#teaching","title":"Teaching","text":"<p>You are being redirected to the Teaching section on the Home page.</p> <p>Go to Teaching </p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"personal/faq/","title":"FAQ","text":""},{"location":"personal/faq/#faq","title":"FAQ","text":""},{"location":"personal/faq/#alexs-answers-to-common-emails","title":"Alex's Answers to Common Emails","text":"<p>I have resigned myself to the fact that I don't have time to answer all of my professional email. If I ignore your message, it's probably because the answer is already on this page, which is divided into the following topics:</p> <ul> <li>Admission to Graduate School</li> <li>Recommendation Letters</li> <li>Visitors</li> <li>Industry Requests for Help Recruiting Students</li> </ul> <p></p>"},{"location":"personal/faq/#admission-to-the-stanford-cs-graduate-programs","title":"Admission to the Stanford CS Graduate Programs","text":"<p>The only way to be admitted is to apply to either the PhD or Masters program. Admission is very competitive, since we receive many more qualified applicants than we can accept. PhD students are almost always guaranteed support by the department. Masters admits are rarely guaranteed financial support.</p> <p>Admission decisions are made entirely by a faculty committee. Individual faculty members cannot accept students on their own.</p> <p></p>"},{"location":"personal/faq/#recommendation-letters","title":"Recommendation Letters","text":"<p>I am happy to write a letter of recommendation for graduate school for any student that I have taught in at least one class. While I will point out what I see as strengths in an application, I won't gloss over weaknesses either. As a rule of thumb, a letter may help you if you received an A or A+, though there have been cases where I felt I could write a strong letter for students whose grades were lower.</p> <p>I need the following at least two weeks before the letter is due:</p> <ul> <li>GPA (cumulative and technical)</li> <li>GRE scores</li> <li>Transcript</li> <li>Statement of purpose</li> <li>A stamped, addressed envelope for each school to which you are   applying that requires a physical letter, and instructions for how to   submit letters for those schools accepting electronic letters.</li> </ul> <p></p>"},{"location":"personal/faq/#visitors","title":"Visitors","text":"<p>I receive many requests to sponsor professional visits, but I simply don't have the capacity to accept more than a very small number of visitors. I will not respond to inquiries about visits unless I think there is a chance that the visit could actually happen.</p> <p></p>"},{"location":"personal/faq/#jobs","title":"Jobs","text":"<p>I generally don't respond to requests for help recruiting students into industry, though I will pass such requests along if I know a well-qualified candidate.</p>"},{"location":"personal/software/","title":"Alex's Software Page","text":""},{"location":"personal/software/#alexs-software-page","title":"Alex's Software Page","text":"<p>I subscribe to the view that computer science researchers in the area of programming languages and software have two ways to disseminate their results. Papers are the means of communicating ideas to other specialists in the area, and implementations are the means of communicating ideas to non-specialists, in the form of tools they can use. My students and I probably devote more effort than is usual in translating our research into software that can be used by others.</p> <p>Here is a list of publicly available software systems with which I have been involved:</p> <ul> <li> <p>Lux is a system for high   performance distributed graph processing. Lux is built on top of   Legion.</p> </li> <li> <p>STOKE is a program   transformation/optimization system for X86 assembly based on   randomized search.</p> </li> <li> <p>Legion is a programming model for   heterogeneous and distributed parallel machines.</p> </li> <li> <p>Terra is a statically typed low-level   language that is integrated with and meta-programmed by Lua (a   dynamically typed high-level language). Terra provides support for   producing very high performance code using meta-programming   techniques.</p> </li> <li> <p>Mistral is a   SMT solver incorporating support for abductive inference and fast   solutions of integer linear constraints.</p> </li> <li> <p>Sixgill is a descendant of the Saturn project   aimed at analysis of large C/C++ systems. As might be expected,   sixgill shares some features with Saturn, but also takes a new   direction in being a near verifier, meaning that it is designed to   be sound and in principle can be made into a full verifier if a few   known soundness holes are plugged with more analysis and any bugs in   sixgill are fixed. Sixgill is also a complete rewrite and shares no   code with Saturn.</p> </li> <li> <p>SAIL is an   intermediate language designed for static analysis; it explicitly both   a high- and a low-level representation, with mappings between them, to   facilitate both analysis (on the low-level representation) and   reporting (through the high-level representation).</p> </li> <li> <p>Sequoia is a programming language for   hierarchical memory machines. A key feature of Sequoia is that data   locality is expressible directly in the language.</p> </li> <li> <p>Saturn is a second-generation   constraint-based analysis framework, primarily exploiting boolean   satisfiability as the underlying constraint language.</p> </li> <li> <p>Banshee, which is a descendant of   the earlier   BANE project,   is a framework for constructing efficient, scalable constraint-based   program analyses. Banshee has been used in a variety of projects   outside our group, including by gcc. UPDATE 2/2015:   Here is an   updated version of Banshee that builds on a current (as of 2015)   32-bit Ubuntu VM. Thank you Collin Gordon!</p> </li> <li> <p>Cooperative Bug Isolation (CBI) is   designed to leverage the power of thousands or millions of users to   help isolate bugs in deployed software systems.</p> </li> <li> <p>CQual is a tool for adding   type qualifiers to C programs to enable additional static checking.</p> </li> <li> <p>Moss is a system for   efficiently detecting copies or partial copies of documents within a   large corpus. Moss, which was first developed in 1994 and released in   1997, is widely used in engineering courses to help detect plagiarism   in programming assignments.</p> </li> <li> <p>CAP is a   descendant of Moss that provides a query interface to millions of   lines of open source software.</p> </li> <li> <p>Titanium is a   memory and type-safe explicitly parallel programming language based on   Java.</p> </li> <li> <p>Datasplash, a tool for   constructing database visualizations.</p> </li> <li> <p>Cool, the   Classroom Object Oriented Language , is a small language designed   for use in an undergraduate compiler course project. While small   enough for a one term project, Cool still has many of the features of   modern programming languages, including objects, inheritance, and   strong static typing.</p> </li> </ul> <p>Cool is built entirely on public domain tools; it generates code for a   MIPS simulator, spim .   Thus, the project should port easily to other platforms. The project   has been used for teaching compilers at many institutions around the   world and the source code is available. The complete Cool distribution   includes the manual, source and makefiles for the compiler, source and   makefiles for each of the assignments, test cases for each of the   assignments, and lecture notes. Because the project is still being   used at Berkeley, only the manual is available here. If you are   interested in obtaining the complete distribution, send mail to   aaiken@stanford.edu.</p> <ul> <li>Illyria was finished in 1994 and is still on this page just for   historical reasons.</li> </ul> <p>Illyria is a small functional language   designed to illustrate a subtype inference system based on solving   systems of type inclusion constraints. Illyria includes the lambda   calculus, polymorphic let, constructors, case expressions, and record   operations. The type language is rich, with union, intersection,   complement, conditional, recursive, and universally quantified types.   This package includes the type inclusion constraint solver, type   inference for Illyria, and examples.</p> <p>Illyria runs under Common Lisp on Unix systems. The only known problem   is that Illyria does not compile under CMU Common Lisp, although it   will run interpreted in that environment. After retrieving the   package, do:</p> <p>% gunzip Illyria.tar.gz</p> <p>% mv Illyria.tar dir/.</p> <p>% cd dir</p> <p>% tar -xvf Illyria.tar</p> <p>See the instructions in the Illyria/README file.</p>"},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#publications","title":"Publications","text":""},{"location":"publications/#books-and-book-articles","title":"Books and Book Articles","text":"<ol> <li>Multifidelity modeling of irradiated particle-laden turbulence     subject to uncertainty.L. Jofre, M. Papadakis, P. T. Roy, A. Aiken     and G. Iaccarino. International Journal for Uncertainty     Quantification 10 (6), 2020.</li> <li>S3D-Legion: An Exascale Software for Direct Numerical Simulation of     Turbulent Combustion with Complex Multicomponent     Chemistry.S.     Treichler, M. Bauer, A. Bhagatwala, G. Borghesi, R. Sankaran, H.     Kolla, P. McCormick, E. Slaughter, W. Lee, A. Aiken and J.     Chen.In T. Straatsma, et al., editors, Exascale Scientific     Applications: Scalability and Performance Portability,CRC Press,     2017.</li> <li>Instruction Level Parallelism.A. Aiken, U. Banerjee, A. Kejariwal     and A. Nicolau.Springer, 2016.</li> <li>A Realistic Resource-Constrained Software Pipelining Algorithm. A.     Aiken and A. Nicolau. In D. Gelernter et al., editors, Advances in     Languages and Compilers for Parallel Processing, pages 274-290, MIT     Press, Cambridge, Massachusetts, 1991.</li> <li>Fine-Grain Parallelization and the Wavefront Method. A. Aiken and A.     Nicolau. In D. Gelernter et al., editors, Languages and Compilers     for Parallel Computing, pages 1-16, MIT Press, Cambridge,     Massachusetts,1990.</li> </ol>"},{"location":"publications/#refereed-journal-articles","title":"Refereed Journal Articles","text":"<ol> <li>Quanto: Optimizing Quantum Circuits with Automatic Generation of     Circuit     Identities.J.     Pointing, O. Padon, Z. Jia, H. Ma, A. Hirth, J. Palsberg and A.     Aiken.Quantum Science and Technology, to appear, 2024.</li> <li>Training with Mixed-Precision Floating-Point     Assignments.W.     Lee, R. Sharma, and A. Aiken.Transactions on Machine Learning     Research, to appear.</li> <li>Multinode Multi-GPU Two-Electron Integrals: Code Generation Using     the Regent     Language.K.     Grace Johnson, S. Mirchandaney, E. Hoag, A. Heirich, A. Aiken and T.     Martinez.Journal of Chemical Theory and Computation, 2022.</li> <li>FLEET--\u2014Fast Lanes for Expedited Execution at 10 Terabits: Program     Overview F.     Douglis, S. Robertson, E. van den Berg, J. Micallef, M. Pucci, A.     Aiken, K. Bergman, M. Hattink and M. Seok.IEEE Internet Computing,     25(3): 2021.</li> <li>A Distributed Multi-GPU System for Fast Graph     Processing. Z.     Jia, Y. Kwon, G. Shipman, P. McCormick, M. Erez, and A. Aiken.     PVLDB, 11(3): 2017.</li> <li>From Invariant Checking to Invariant Inference Using Randomized     Search     (invited paper).R. Sharma and A. Aiken.Formal Methods in System     Design,48(3), pages 235-256, March, 2016.</li> <li>Stochastic Program     Optimization.E.     Schkufza, R. Sharma and A. Aiken. Communications of the     ACM,research highlight,59(2):114-122,February, 2016.</li> <li>An Introduction to Data Representation     Synthesis.P.     Hawkins, A. Aiken, K. Fisher, M. Rinard, and M. Sagiv.     Communications of the ACM,research     highlight,55(12):91-99,December, 2012.</li> <li>Cuts from Proofs: A Complete and Practical Technique for Solving     Linear Inequalities Over     Integers.I.     Dillig, T. Dillig and A. Aiken. Formal Methods in System Design     ,invited paper, 39:246-260, January 2011.</li> <li>Reasoning About the Unknown in Static     Analysis.I.     Dillig, T. Dillig and A. Aiken. Communications of the ACM,research     highlight,53(8):115-123, August 2010.</li> <li>A Capability Calculus for Concurrency and     Determinism (extended version).T. Terauchi and A.     Aiken. Transactions on Programming Languages and     Systems,30(5):1-30, August 2008.</li> <li>Witnessing Side Effects (Extended     Version). T. Terauchi and A. Aiken.     Transactions on Programming Languages and Systems,30(3):1-42,     2008.</li> <li>Saturn: A Scalable Framework for Error Detection using Boolean     Satisfiability.Y.     Xie and A. Aiken. Transactions on Programming Languages and     Systems,29(3):1-16, 2007.</li> <li>Flow-Insensitive Type Qualifiers. J.     Foster, J. Kodumal, R. Johnson, and A. Aiken. Transactions on     Programming Languages and Systems, 28(6):1035-1087, 2006.</li> <li>A Direct Manipulation Environment for Programming Semantic Zoom     Visualizations of Tabular     Data.A.     Woodruff, C. Olston, A. Aiken, M. Chu, V. Ercegovac, M. Lin, M.     Spalding, and M. Stonebraker,Journal of Visual Languages and     Computing,12(5):551-571.</li> <li>Detecting Races in Relay Ladder Logic     Programs.     (invited paper)Z. Su, A. Aiken, and M. F\u00e4hndrich.Software Tools for     Technology Transfer,3(2000):93-105.</li> <li>Introduction to Set Constraint-Based Program     Analysis. A.     Aiken. Science of Computer Programming, 35(1999):79-111, 1999.</li> <li>Optimal Representations of Polymorphic Types with     Subtyping. A.     Aiken, E. Wimmers, J. Palsberg. Higher-Order and Symbolic     Computation, 12(3), October 1999.</li> <li>Resource-Constrained Software     Pipelining, A.     Aiken, A. Nicolau, and S. Novack. IEEE Transactions on Distributed     and Parallel Systems, 6(12):1248-1270, December 1995.</li> <li>Decidability of Systems of Set Constraints with Negative     Constraints. A.     Aiken, D. Kozen, and E. Wimmers. Information and Computation,     122(1):30-44,October 1995.</li> <li>Static Analysis Techniques for Predicting the Behavior of Active     Database     Rules.A.     Aiken, J. Widom, and J. M. Hellerstein. ACM Transactions on     Database Systems, 20(1):63-84, March 1995.</li> <li>Safe-A Semantic Technique for Transforming Programs in the Presence     of     Errors.A.     Aiken, J. Williams, and E. Wimmers. ACM Transactions on Programming     Languages and Systems, 17(1):63-84, January 1995.</li> <li>A Theory of Compaction-Based     Parallelization. A.     Aiken. Theoretical Computer Science, 73(2):121-154, June 1990.</li> <li>Fine-Grain Compilation for Pipelined     Machines. A.     Nicolau, K. Pingali and A. Aiken. Journal of Supercomputing,     2(3):279-295, November 1988.</li> <li>A Development Environment for Horizontal     Microcode     (revised). A. Aiken and A. Nicolau. IEEE Transactions on Software     Engineering,14(5): 584-594, May 1988.</li> </ol>"},{"location":"publications/#refereed-conference-and-workshop-articles","title":"Refereed Conference and Workshop Articles","text":"<ol> <li> <p>D. Zhang, R. Yadav, A. Aiken, F Kjolstad, and S.     Treichler.KDRSolvers: Scalable, Flexible, Task-Oriented Krylov     Solvers.Proceedings of the Workshop on the Parallel Applications     Workshop, Alternatives to MPI+X, November, 2025.</p> </li> <li> <p>A. Das and A. Aiken.Flexible Windowing for Correlation-Aware Ranking     in Anomalous Environments.Proceedings of the International     Conference on Data Mining, November 2025.</p> </li> <li> <p>EquiBench: Benchmarking Large Language Models' Understanding of     Program Semantics via Equivalence Checking.A. Wei, J. Cao, R. Li, H.     Chen, Y. Zhang, Z. Wang, Y. Liu, T. Teixeira, D. Yang, K. Wang     and A. Aiken.Proceedings of the Conference on Empirical Methods in     Natural Language Processing, November, 2025.</p> </li> <li> <p>SATBench: Benchmarking LLMs' Logical Reasoning via Automated Puzzle     Generation from SAT Formulas.A. Wei, Y. Wu, Y. Wan, T. Suresh, H.     Tan, Z. Zhou, S. Koyejo, K. Wang and A. Aiken.Proceedings of the     Conference on Empirical Methods in Natural Language Processing,     November, 2025.</p> </li> <li> <p>High-Performance Branch-Free Algorithms for Extended-Precision     Floating-Point     Arithmetic.D.     Zhang and A. Aiken.Proceedings of the International Conference on     Supercomputing, November, 2025.</p> </li> <li> <p>Improving Parallel Program Performance with LLM Optimizers via     Agent-System Interfaces.A. Wei, A. Nie, T. Teixeira, R. Yadav, W.     Lee, K. Wang and A. Aiken.Proceedings of the International     Conference on Machine Learning, July, 2025.</p> </li> <li> <p>LogCloud: Fast Search of Compressed Logs on Object     Storage.Z.     Wang, J. Wei, A. Aiken, G. Zhang, J. Toerring, R. Jiang, C. Jiang     and W. Xu.Proceedings of the VLDB, September, 2025.</p> </li> <li> <p>Automatic Verification of Floating-Point Accumulation     Networks.D.     Zhang and A. Aiken.Proceedings of the Conference on Computer Aided     Verification, July, 2025.</p> </li> <li> <p>Task-Based Tensor Computations on Modern     GPUs.R. Yadav, M.     Garland, A.Aiken and M. Bauer.Proceedings of the Conference on     Programming Language Design and Implementation, June, 2025.</p> </li> <li> <p>Rottnest: Indexing Data Lakes for     Search.Z.     Wang, C. Kennedy, R. Jiang, W. Pace, H. Zhang, A. Aiken.Proceedings     of the International Conference on Data Engineering, May, 2025.</p> </li> <li> <p>Automatic Tracing in Task-Based Runtime     Systems.R. Yadav, M. Bauer, D.     Broman, M. Garland, A. Aiken and F. Kjolstad.Proceedings of the     Conference on Architectural Support for Programming Languages and     Operating Systems, March, 2025.</p> </li> <li> <p>Composing Distributed Computations Through Taskand Kernel     Fusion.R. Yadav, S. Sundram, W.     Lee, M. Garland, M. Bauer, A. Aiken and F. Kjolstad.Proceedings of     the Conference on Architectural Support for Programming Languages     and Operating Systems, March, 2025.</p> </li> <li> <p>CommBench: Micro-Benchmarking Hierarchical Networks with Multi-GPU,     Multi-NIC     Nodes.M.     Hidayetoglu, S. Garcia de Gonzalo, E. Slaughter, Y. Li, C.     Zimmer, T. Bicer, B. Ren, W. Gropp, W. Hwu, A. Aiken.Proceedings of     the International Conference on Supercomputing, June, 2024.</p> </li> <li> <p>Recursive Program Synthesis Using     Paramorphisms.Q.     Hong and A. Aiken. Proceedings of the Conference on Programming     Language Design and Implementation, June, 2024.</p> </li> <li> <p>Efficient Fault Tolerance for Pipelined Query Engines via     Write-ahead     Lineage.Z.     Wang and A. Aiken. Proceedings of the International Conference on     Data Engineering,May, 2024.</p> </li> <li> <p>Speaking Pygion: Experiences Writing anExascale Single Particle     Imaging     Code.S.     Mirchandaney, A. Aiken and E. Slaughter.Proceedings of the Workshop     on Asynchronous Many-Task Systems and Applications,February, 2024.</p> </li> <li> <p>Automated Mapping of Task-Based Programs onto Distributedand     Heterogeneous     Machines.T.     Teixeira, A. Henzinger, R. Yadav and A. Aiken. Proceedings of the     International Conference on Supercomputing,November, 2023.</p> </li> <li> <p>Legate Sparse: Distributed Sparse Computing in     Python.R.     Yadav, W. Lee, M. Elibol, T. Patti, M. Papadakis, M. Garland, A.     Aiken, F. Kjoldstad, M. Bauer.Proceedings of the International     Conference on Supercomputing,November, 2023.</p> </li> <li> <p>Prolego: Time-Series Analysis for Predicting Failuresin Complex     Systems.A.     Das and A. Aiken.Proceedings of the Conference on Autonomic     Computing and Self-Organizing Systems,July, 2023.</p> </li> <li> <p>On the Correctness of Automatic Differentiation for Neural Networks     with Machine-Representable     Parameters.W.     Lee, S. Park and A. Aiken.Proceedings of the International     Conference on Machine Learning,September, 2023.</p> </li> <li> <p>Putting People in Their Place: Affordance-Aware Human Insertion     into     Scenes.S.     Kulal, T. Brooks, A. Aiken, J. Wu, J. Yang, J. Lu, A. Efros and K.     Singh.Proceedings of the Conference on Computer Vision and Pattern     Recognition,June, 2023.</p> </li> <li> <p>Visibility Algorithms for Dynamic Dependence Analysis and     Distributed     Coherence.M.     Bauer, E. Slaughter, S. Treichler, W. Lee, M. Garland and A.     Aiken.Proceedings of Principles and Practice of Parallel     Programming,February, 2023.</p> </li> <li> <p>Task Fusion in Distributed     Runtimes.S.     Sundram, W. Lee and A. Aiken.Proceedings of the Workshop on the     Parallel Applications Workshop, Alternatives to MPI+X, November,     2022.</p> </li> <li> <p>Performance Variability and Causality in Complex     Systems.A.     Das, D. Ratner and A. Aiken.Proceedings of the International     Conference on Autonomic Computing and Self-Organizing Systems,     September, 2022.</p> </li> <li> <p>SpDISTAL: Compiling Distributed Sparse Tensor     Computations.R.     Yadav, A. Aiken and F. Kjolstad.Proceedings of the International     Conference on Supercomputing, November, 2022.</p> </li> <li> <p>Accelerating DNN Training Through Joint Optimization of Algebraic     Transformations and     Parallelization.C.     Unger,Z. Jia,W. Wu,S. Lin,M. Baines,C. E. Q. Narvaez,V.     Ramakrishnaiah,N. Prajapati,P. McCormick,J. Mohd-Yusof,X. Luo,D.     Mudigere,J. Park,M. Smelyanskiy andA. Aiken.Proceedings of the     Symposium on Operating System Design and Implementation, July 2022.</p> </li> <li> <p>Programmatic Concept Learning for Human Motion Description and     Synthesis. S.     Kulal, J. Mao, A. Aiken and J. Wu.Proceedings of the Conference on     Computer Vision and Pattern Recognition,June 2022.</p> </li> <li> <p>DISTAL: The Distributed Tensor Algebra     Compiler.R.     Yadav, A. Aiken and F. Kjolstad.Proceedings of the Conference on     Programming Language Design and Implementation, June 2022.</p> </li> <li> <p>Quartz: Superoptimization of Quantum     Circuits.M.     Xu, Z. Li, O. Padon, S. Lin, J. Pointing, A. Hirth, H. Ma, J.     Palsberg, A. Aiken, U. Acar and Z. Jia.Proceedings of the Conference     on Programming Language Design and Implementation, June 2022.</p> </li> <li> <p>Inferring Invariants with Quantifier Alternations: Taming the     Search Space     Explosion.J.     Koenig, O. Padon, S. Shoham, and A. Aiken. Proceedings of the     International Conference on Tools and Algorithms for the     Construction and Analysis of Systems (TACAS).April, 2022.</p> </li> <li> <p>Induction Duality: Primal-Dual Search for     Invariants.O.     Padon, J. R. Wilcox, J. R. Koenig, K. McMillan, and A.     Aiken.Proceedings of the Symposium on Principles of Programming     Languages,January, 2022.</p> </li> <li> <p>Index Launches: Scalable, Flexible Representation of Parallel Task     Groups.R.     Soi, M. Bauer, S. Treichler, M. Papadakis, W. Lee, P. McCormick, A.     Aiken and E. Slaughter.Proceedings of the International Conference     on Supercomputing,November, 2021.</p> </li> <li> <p>Adaptive Restarts for Stochastic     Synthesis.J.     Koenig, O. Padon and A. Aiken.Proceedings of the Conference on     Programming Language Design and Implementation, June 2021.</p> </li> <li> <p>Hierarchical Motion Understanding via Motion     Programs.S.     Kulal, J. Mao, A. Aiken and J. Wu.Proceedings of the Conference on     Computer Vision and Pattern Recognition,June 2021.</p> </li> <li> <p>Scaling Implicit Parallelism via Dynamic Control     Replication.M     Bauer, W. Lee, E. Slaughter, Z. Jia, M. Di Renzo, M. Papadakis, G.     Shipman, P. McCormick, M. Garland, A. Aiken.Proceedings of     Principles and Practice of Parallel Programming,February, 2021.</p> </li> <li> <p>Development of a Discontinuous Galerkin Solver Using Legion for     Heterogeneous High-Performance Computing Architectures. K. Bando, S.     Brill, E. Slaughter, M. Sekachev, A. Aiken and M. Ihme. AIAA Scitech     Forum, January, 2021.</p> </li> <li> <p>Task Bench: A Parameterized Benchmark for Evaluating Parallel     Runtime     Performance.E.     Slaughter, W. Wu, Y. Fu, L. Brandenburg, N. Garcia, E. Marx, K.S.     Morris, Q. Cao, G. Bosilca, S. Mirchandaney, W. Lee, S. Treichler, P     McCormick and A. Aiken.Proceedings of the International Conference     on Supercomputing,November, 2020.</p> </li> <li> <p>Redundancy-Free Computation Graphs for Graph Neural     Networks.Z.Jia, S.     Lin, R. Ying, J. You, J. Leskovec and A. Aiken.Proceedings of the     International Conference on Knowledge Discovery and Data Mining,     August 2020.</p> </li> <li> <p>First-Order Quantified     Separators,J.     Koenig, O. Padon, N. Immerman and A. Aiken.Proceedings of the     Conference on Programming Language Design and Implementation, June     2020.</p> </li> <li> <p>Improving the Accuracy, Scalability, and Performance of Graph     Neural Networks with     Roc,Z.     Jia, S. Lin, M. Gao, M. Zaharia and A. Aiken.Proceedings of the     Conference on Machine Learning and Systems, March 2020.</p> </li> <li> <p>Pygion: Flexible, Scalable Task-Based Parallelism with     Python,E.     Slaughter and A. Aiken.Proceedings of the Workshop on the Parallel     Applications Workshop, Alternatives to MPI+X,November, 2019.</p> </li> <li> <p>Soleil-X: Turbulence, Particles, and Radiation in the Regent     Programming     Language,H.     Torres, M. Papadakis, L. Jofre, W. Lee, A. Aiken, and G.     Iaccarino.Proceedings of the Workshop on the Parallel Applications     Workshop, Alternatives to MPI+X,November, 2019.</p> </li> <li> <p>A Constraint-Based Approach to Automatic Data Partitioning for     Distributed Memory     Execution,W.     Lee, M. Papadakis, E. Slaughter and A. Aiken.Proceedings of the     International Conference on Supercomputing,November, 2019.</p> </li> <li> <p>TASO: Optimizing Deep Learning Computation with Automated     Generation of Graph     Substitutions,Z.     Jia, O. Padon, J. Thomas, T. Warszawski, M. Zaharia, A.     Aiken.Proceedings of the Symposium on Operating Systems     Principles,October, 2019.</p> </li> <li> <p>Eventually Sound Points-To Analysis with     Specifications,O.     Bastani, R. Sharma, L. Clapp, S. Anand and A. Aiken.Proceedings of     the European Conference on Object-Oriented Programming,July, 2019.     (Extended     version     with proofs.)</p> </li> <li> <p>Semantic Program Alignment for Equivalence     Checking.B.     Churchill, O. Padon, R Sharma and A. Aiken.Proceedings of the     Conference on Programming Language Design and Implementation,June,     2019.</p> </li> <li> <p>Beyond Data and Model Parallelism for Deep Neural     Networks.Z.     Jia, M. Zaharia and A. Aiken.Proceedings of the SysML     Conference,April, 2019.</p> </li> <li> <p>Optimizing DNN Computation With Relaxed Graph     Substitutions.Z.     Jia, J. Thomas, T. Warszawski, M. Gao, M. Zaharia and A.     Aiken.Proceedings of the SysML Conference,April, 2019.</p> </li> <li> <p>Correctness of Dynamic Dependence Analysis for Implicitly Parallel     Tasking     Systems. W.     Lee, G. Stelle, P. McCormick and A. Aiken.Proceedings of the     International Workshop on Software Correctness for HPC     Applications,November, 2018.</p> </li> <li> <p>Dynamic Tracing: Just-In-Time Specialization of Task Graphs for     Dynamic Task-based     Runtimes.W.     Lee, E. Slaughter, M. Bauer, S. Treichler, T. Warszawski, M. Garland     and A. Aiken.Proceedings of the International Conference on     Supercomputing,November, 2018.</p> </li> <li> <p>Exploring Hidden Dimensions in Parallelizing Convolutional Neural     Networks,Z.     Jia, S. Lin, C. R. Qi and A. Aiken.Proceedings of the International     Conference on Machine Learning,July 2018. Extended     version     with proofs.</p> </li> <li> <p>Active Learning of Points-To     Specifications.O.     Bastani, R. Sharma, A. Aiken and P. Liang.Proceedings of the     Conference on Programming Language Design and Implementation,June     2018.</p> </li> <li> <p>Isometry: A Path-Based Distributed Data Transfer     System.Z.     Jia, S. Treichler, G. Shipman, P. McCormick and A. Aiken.Proceedings     of the International Conference on Supercomputing,June 2018.</p> </li> <li> <p>On Automatically Proving the Correctness of math.h     Implementations, W.     Lee, R. Sharma and A. Aiken.Proceedings of the Symposium on     Principles of Programming Languages,January 2018.</p> </li> <li> <p>Integrating External Resources with a Task-Based Programming     Model.Z.     Jia, S. Treichler, G. Shipman, M. Bauer, N. Watkins, C. Maltzahn, P.     McCormick and A. Aiken.Proceedings of the International Conference     on High Performance Computing, Data, and Analytics,December 2017.</p> </li> <li> <p>Seam: Provably Safe Local Edits on     Graphs.M.     Papadakis, G. Bernstein, R. Sharma, A. Aiken and P.     Hanrahan.Proceedings of the International Conference on     Object-Oriented Programming, Systems, Languages, and Applications,     November 2017.</p> </li> <li> <p>In situ Visualization with Task-Based     Parallelism,A.     Heirich, E. Slaughter, M. Papadakis, W. Lee, T. Biedert and A.     Aiken.Proceedings of the Workshop on In Situ Infrastructures for     Enabling Extreme-scale Analysis and Visualization,November 2017.</p> </li> <li> <p>Control Replication: Compiling Implicit Parallelism to Efficient     SPMD with Logical     Regions.E.     Slaughter, W. Lee, S. Treichler, W. Zhang, M. Bauer, G. Shipman, P.     McCormick and A. Aiken.Proceedings of the Conference on     Supercomputing, November 2017.</p> </li> <li> <p>Synthesizing Program Input     Grammars.O.     Bastani, R. Sharma, A. Aiken and P. Liang.Proceedings of the     Conference on Programming Language Design and Implementation,pages     95-110, June 2017.(Extended     version     with proofs)</p> </li> <li> <p>Sound Loop Superoptimization for Google Native     Client.B.     Churchill, R. Sharma, J.-F. Bastien and A. Aiken.Proceedings of the     Conference on Architectural Support for Programming Languages and     Operating Systems,pages 313-326, April 2017.</p> </li> <li> <p>Minimizing GUI Event     Traces.L.     Clapp, O. Bastani, S. Anand and A. Aiken.Proceedings of the     International Symposium on the Foundations of Software     Engineering.pages 422-434, November 2016.</p> </li> <li> <p>Dependent     Partitioning.S.     Treichler, M. Bauer, R. Sharma, E. Slaughter and A.     Aiken.Proceedings of the International Conference on Object-Oriented     Programming, Systems, Languages, and Applications, pages 344-358,     November 2016.</p> </li> <li> <p>Stratified Synthesis: Automatically Learning the x86-64 Instruction     Set,S.     Heule, E. Schkufza, R. Sharma and A. Aiken.Proceedings of the     Conference on Programming Language Design and Implementation,pages     237-250, June 2016.</p> </li> <li> <p>Verifying Bit-Manipulations of     Floating-Point,W.     Lee, R. Sharma and A. Aiken.Proceedings of the Conference on     Programming Language Design and Implementation,pages 70-84, June     2016.</p> </li> <li> <p>Towards Asynchornous Many-Task In Situ Data Analysis Using     Legion,P.     Pebay, J. Bennett, D. Hollman, S. Treichler, P. McCormick, C.     Sweeney, H. Kolla and A. Aiken.Proceedings of the International     Parallel Processing and Distributed Processing Symposium,May 2016</p> </li> <li> <p>Analysis of Application Sensitivity to System Performance     Variability in a Dynamic Task Based     Runtime,G.     Shipman, P. McCormick, K. Pedretti, S. Olivier, K. Ferreira, R.     Sankaran, S. Treichler, A. Aiken and M. Bauer.Proceedings of the     Workshop on Runtime Systems for Extreme Scale Programming Models and     Architectures, November 2015</p> </li> <li> <p>Automatic and Transparent I/O Optimization With Storage Integrated     Application Runtime     Support,N.     Watkins, Z. Jia, G. Shipman,C. Maltzahn, A. Aiken and P.     McCormick.Proceedings of the Parallel Data Storage Workshop,November     2015.</p> </li> <li> <p>Regent: A High-Productivity Programming Language for HPC with     Logical     Regions,E.     Slaughter, W. Lee, S. Treichler, M. Bauer and A. Aiken.Proceedings     of the Conference on Supercomputing, November 2015.</p> </li> <li> <p>An Interactive Approach to Mobile App     Verification,O.     Bastani, S. Anand and A. Aiken.Proceedings of the Workshop on Mobile     Development Lifecycle,pages 45-46, October 2015.</p> </li> <li> <p>Conditionally Correct      Superoptimization,R.      Sharma, E. Schkufza, B. Churchill and A. Aiken.Proceedings of the      International Conference on Object-Oriented Programming, Systems,      Languages, and Applications, pages 147-162, October 2015.</p> </li> <li> <p>Interactively Verifying Absence of Explicit Information Flows in      Android      Apps,O.      Bastani, S. Anand and A. Aiken.Proceedings of the International      Conference on Object-Oriented Programming, Systems, Languages, and      Applications, pages 299-315, October 2015.</p> </li> <li> <p>Modelgen: Mining Explicit Information Flow Specifications from      Concrete      Executions,L.      Clapp, S. Anand and A. Aiken.Proceedings of the International      Symposium on Software Testing and Analysis,pages 129-140, July      2015.</p> </li> <li> <p>Composing Concurrency      Control,O.      Ziv, A. Aiken, G. Golan-Gueta, G. Ramalingam and M.      Sagiv.Proceedings of the Conference on Programming Language Design      and Implementation,pages 240-249, June 2015.</p> </li> <li> <p>Verification of Producer-Consumer Synchronization in GPU      Programs,M.      Bauer, R. Sharma and A. Aiken.Proceedings of the Conference on      Programming Language Design and Implementation,pages 88-98, June      2015.</p> </li> <li> <p>Specification Inference Using Context-Free Language      Reachability,O.      Bastani, S. Anand and A. Aiken.Proceedings of the Symposium on      Principles of Programming Languages,pages 553-566, January 2015.</p> </li> <li> <p>Structure Slicing: Extending Logical Regions with      Fields.M.      Bauer, S. Treichler, E. Slaughter and A. Aiken.Proceedings of the      Conference on Supercomputing, pages 845-856, November 2014.</p> </li> <li> <p>Apposcopy: Semantics-Based Detection of Android Malware Through      Static      Analysis.Y.      Feng, S. Anand, I. Dillig and A. Aiken.Proceedings of the      International Symposium on Foundations of Software      Engineering.pages 576-587, November 2014.</p> </li> <li> <p>Realm: An Event-Based Low-Level Runtime for Distributed Memory      Architectures.S.      Treichler, M. Bauer and A. Aiken.Proceedings of the International      Conference on Parallel Architectures and Compilations      Techniques.pages 263-276, August 2014.</p> </li> <li> <p>Verifying Atomicity via Data      Independence.O.      Shacham, E. Yahav, G. Gueta, A. Aiken, N. Bronson, M. Sagiv and M.      Vechev.Proceedings of the International Symposium on Software      Testing and Analysis.pages 26-36, July 2014.</p> </li> <li> <p>From Invariant Checking to Invariant Inference Using Randomized      Search.R.      Sharma and A. Aiken.Proceedings of the International Conference on      Computer Aided Verification.pages 88-105, Juy 2014.</p> </li> <li> <p>M3: High-Performance Memory Management from Off-the-Shelf      Components.D.      Terei, A. Aiken and J. Vitek. Proceedings of the International      Symposium on Memory Management.pages 3-13, June 2014.</p> </li> <li> <p>Stochastic Optimization of Floating Point Programs with Tunable      Precision.E.      Schkufza, E. Sharma and A. Aiken.Proceedings of the Conference on      Programming Language Design and Implementation.pages 53-64, June      2014.</p> </li> <li> <p>First-class Runtime Generation of High-performance Types using      Exotypes.Z.      DeVito, D. Ritchie, M. Fisher, A. Aiken and P. Hanrahan.Proceedings      of the Conference on Programming Language Design and      Implementation.pages 77-88, June 2014.</p> </li> <li> <p>Singe: Leveraging Warp Specialization for High Performance on      GPUs.M.      Bauer, S. Treichler and A.Aiken.Proceedings of the Symposium on      Principles and Practice of Parallel Programming,pages 119-130,      February 2014.</p> </li> <li> <p>Bias-Variance Tradeoffs in Program      Analysis.R.      Sharma, A. Aiken and A. Nori.Proceedings of the Symposium on      Principles of Programming Languages,pages 127-137, January 2014.</p> </li> <li> <p>Language Support for Dynamic, Hierarchical Data      Partitioning.S.      Treichler, M. Bauer and A. Aiken. Proceedings of the International      Conference on Object-Oriented Programming, Systems, Languages, and      Applications, pages 495-514, October 2013.</p> <p>(Extended  version  with proofs)</p> </li> <li> <p>Data-Driven Equivalence      Checking.R.      Sharma, E. Schkufza, B. Churchill and A. Aiken. Proceedings of the      International Conference on Object-Oriented Programming, Systems,      Languages, and Applications, pages 391-406, October 2013.</p> </li> <li> <p>Crowd-scale Interactive Formal Reasoning and      Analytics.E.      Fast, C. Lee, A. Aiken, M. Bernstein, D. Koller and E.      Smith.Proceedings of the Symposium on User Interface Software and      Technology,pages 363-372, October, 2013.</p> </li> <li> <p>Verification as Learning Geometric      Concepts.R.      Sharma, S. Gupta, B. Hariharan, A. Aiken and A. Nori.Proceedings of      the Static Analysis Symposium,pages 388-411, June 2013.</p> </li> <li> <p>Terra: A Multi-Stage Language for High Performance      Computing.Z.      DeVito, J. Hegarty, A. Aiken, P. Hanrahan and J. Vitek.Proceedings      of the Conference on Programming Language Design and      Implementation,pages 105-116, June 2013.</p> </li> <li> <p>A Data Driven Approach for Algebraic Loop      Invariants.R.      Sharma, S. Gupta, B. Hariharan, A. Aiken, P. Liang and A. V.      Nori.Proceedings of the European Symposium on Programming,pages      574-592, March 2013.</p> </li> <li> <p>Stochastic      Superoptimization.E.      Schkufza, R. Sharma and A. Aiken.Proceedings of the International      Conference on Architectural Support for Programming Languages and      Operating Systems,pages 305-316, March 2013.</p> <p>Note: This paper has an  errata  page.</p> </li> <li> <p>Legion: Expressing Locality and Independence with Logical      Regions.M.      Bauer, S. Treichler, E. Slaughter and A. Aiken.Proceedings of the      Conference on Supercomputing, pages 1-11, November 2012.</p> </li> <li> <p>Understanding the Behavior of Database Operations under Program      Control.J.      Tamayo, A. Aiken, N. Bronson and M. Sagiv.Proceedings of the      International Conference on Object-Oriented Programming, Systems,      Languages, and Applications, pages 983-996, October 2012.</p> </li> <li> <p>Interpolants as      Classifiers.R.      Sharma, A. Nori and A. Aiken. Proceedings of the International      Conference on Computer Aided Verification,pages 71-87, July 2012.</p> </li> <li> <p>Minimum Satisfying Assignments for      SMT.I.      Dillig, T. Dillig, K. McMillan and A. Aiken. Proceedings of the      International Conference on Computer Aided Verification.pages      394-409, July 2012.</p> </li> <li> <p>Automated Error Diagnosis Using Abductive Inference.I.  Dillig, T. Dillig      and A. Aiken. Proceedings of the Conference on Programming Language Design and Implementation,      pages 181-192,June 2012.</p> <p>( extended version with proofs)</p> </li> <li> <p>Concurrent Data Representation      Synthesis.P.      Hawkins, A. Aiken, K. Fisher, M. Rinard, and M. Sagiv.Proceedings      of the Conference on Programming Language Design and      Implementation, pages 417-428,June 2012.</p> </li> <li> <p>Reasoning About Lock      Placements.P.      Hawkins, A. Aiken, K. Fisher, M. Rinard, and M. Sagiv.Proceedings      of the European Symposium on Programming, pages 336-356,March 2012.</p> </li> <li> <p>Liszt: A Domain Specific Language for Building Portable Mesh-based      PDE      Solvers. Z.      DeVito, N. Joubert, F. Palacios, S. Oakley, M. Medina, M.      Barrientos, E. Elsen, F. Ham, A. Aiken,K. Duraisamy, E. Darve, J.      Alonso, P. Hanrahan.Proceedings of the Conference on      Supercomputing, pages 9:1-9:12, November 2011.</p> </li> <li> <p>Testing Atomicity of Composed Concurrent      Operations.O.      Shacham, N. Bronson, A. Aiken, M. Sagiv, M. Vechev, and E.      Yahav.Proceedings of the International Conference on      Object-Oriented Programming, Systems, Languages, and Applications,      pages 51-64, October 2011.</p> </li> <li> <p>Automatic Fine-Grain Locking Using Shape      Properties.G.      Golan-Gueta, N. Bronson, A. Aiken, G. Ramalingam, M. Sagiv, E.      Yahav.Proceedings of the International Conference on      Object-Oriented Programming, Systems, Languages, and Applications,      pages 225-242, October 2011.</p> </li> <li> <p>Inferring Data Polymorphism in Systems      Code.B.      Hackett and A. Aiken.Proceedings of the Symposium on Foundations of      Software Engineering,pages 332-342, September 2011.</p> </li> <li> <p>Simplifying Loop Invariant Generation Using Splitter      Predicates.[Full      Paper]R.      Sharma, I. Dillig, T. Dillig, and A. Aiken.Proceedings of the      International Conference on Computer Aided Verification.pages      703-719, July 2011.</p> </li> <li> <p>Online Detection of Multi-Component Interactions in Production      Systems.A.      Oliner and A. Aiken.Proceedings of the International Conference on      Dependable Systems and Networks, pages 49-60, June 2011.</p> </li> <li> <p>Data Representation      Synthesis.P.      Hawkins, A. Aiken, K. Fisher, M, Rinard and M. Sagiv.Proceedings of      the Conference on Programming Language Design and      Implementation,pages 38-49, June 2011.</p> </li> <li> <p>Precise and Compact Modular Procedure Summaries for Heap      Manipulating      Programs.I.      Dillig, T. Dillig, A. Aiken, and M. Sagiv.Proceedings of the      Conference on Programming Language Design and Implementation.pages      567-577, June 2011.</p> </li> <li> <p>Programming the Memory Hierarchy Revisited: Supporting Irregular      Parallelism in      Sequoia.M.      Bauer, J. Clark, E. Schkufza, and A. Aiken.Proceedings of the      Symposium on Principles and Practice of Parallel Programming,pages      13-24, February 2011.</p> </li> <li> <p>Precise Reasoning for Programs Using      Containers.I.      Dillig, T. Dillig, and A. Aiken.Proceedings of the Symposium on      Principles of Programming Languages,pages 187-200, January 2011.</p> </li> <li> <p>Data Structure      Fusion.P.      Hawkins, A. Aiken, K. Fisher, M.Rinard, and M. Sagiv.Proceedings of      the Asian Symposium on Programming Languages and Systems, pages      204-221, November 2010.</p> </li> <li> <p>Symbolic Heap Abstraction with Demand-Driven Axiomatization of      Memory      Invariants.I.      Dillig, T. Dillig and A. Aiken.Proceedings of the International      Conference on Object-Oriented Programming, Systems, Languages, and      Applications, pages 397-410, October 2010.</p> </li> <li> <p>Community Epidemic Detection using Time-Correlated      Anomalies.A.      Oliner, A. v. Kulkarni and A. Aiken.Proceedings of the      International Symposium on Recent Advances in Intrusion Detection,      pages 360-381, September 2010.</p> </li> <li> <p>Small Formulas for Large Programs: On-line Constraint      Simplification in Scalable Static      Analysis.I.      Dillig, T. Dillig and A. Aiken.Proceedings of the International      Static Analysis Symposium, pages 236-252, September 2010.</p> </li> <li> <p>A Query Language for Understanding Component Interactions in      Production      Systems.A.      Oliner and A. Aiken.Proceedings of the International Conference on      Supercomputing, pages 201-210, June 2010.</p> </li> <li> <p>Using Correlated Surprise to Infer Shared      Influence.A.      Oliner, A. V. Kulkarni and A. Aiken.Proceedings of the      International Conference on Dependable Systems and Networks, pages      191-200, June 2010.</p> </li> <li> <p>Fluid Updates: Beyond Strong vs. Weak      Updates.I.      Dillig, T. Dillig and A. Aiken.Proceedings of the European      Symposium on Programming, pages 246-266, March 2010.</p> </li> <li> <p>Expanding the Frontiers of Computer Science: Designing a      Curriculum to Reflect a Diverse      Field.M.      Sahami, A. Aiken, and J. Zelenski.Proceedings of the Symposium on      Computer Science Education, pages 47-51, March 2010.</p> </li> <li> <p>Cuts from Proofs: A Complete and Practical Technique for Solving      Linear Inequalities over      Integers.I.      Dillig, T. Dillig, and A. Aiken.Proceedings of the International      Conference on Computer Aided Verification,pages 233-247, June 2009.</p> </li> <li> <p>Alert Detection in System Logs (short      paper).A. Oliner, J. Stearley, and A. Aiken.Proceedings of the      International Conference on Data Mining,pages 959-964, December      2008.</p> </li> <li> <p>Binary Translation Using Peephole      Superoptimizers.S. Bansal and A.      Aiken.Proceedings of the Symposium on Operating System Design and      Implementation,pages 177-192, December 2008.</p> </li> <li> <p>A Tuning Framework for Software-Managed Memory      Hierarchies.M. Ren, M. Houston, J.-Y. Park, W.      Dally, and A. Aiken.Proceedings of the Conference on Parallel      Architectures and Compilation Techniques, pages 280-291, October      2008.</p> </li> <li> <p>Sound, Complete and Scalable Path-Sensitive      Analysis.I. Dillig, T. Dillig, and A.      Aiken.Proceedings of the Conference on Programming Language Design      and Implementation, pages 270-280, June 2008.</p> </li> <li> <p>Verifying the Safety of User Pointer      Dereferences.S. Bugrara and A.      Aiken.Proceedings of the IEEE Symposium on Security and      Privacy,pages 325-338, May 2008.</p> </li> <li> <p>A Portable Runtime Interface For Multi-Level Memory      Hierarchies. M. Houston, J.-Y. Park, M.      Ren, T. Knight, K. Fatahalian, A. Aiken, W. Dally, and P.      Hanrahan.Proceedings of the Symposium on Principles and Practice of      Parallel Programming, pages 143-152, February 2008.</p> </li> <li> <p>Measuring Empirical Computational Complexity.S.      Goldsmith, A. Aiken, and D. Wilkerson.Proceedings of the Symposium      on Foundations of Software Engineering, pages 395-404, September      2007.</p> </li> <li> <p>An Overview of the Saturn Project.A.      Aiken, S. Bugrara, I. Dillig, T. Dillig, P. Hawkins and B.      Hackett.Proceedings of the Workshop on Program Analysis for      Software Tools and Engineering, pages 43-48, June 2007.</p> </li> <li> <p>Static Error Detection Using Semantic Inconsistency      Inference.I. Dillig, T. Dillig, and A.      Aiken.Proceedings of the Conference on Programming Language Design      and Implementation, pages 435-446, June 2007.</p> </li> <li> <p>Regularly Annotated Set Constraints.J. Kodumal      and A. Aiken.Proceedings of the Conference on Programming Language      Design and Implementation, pages 331-341, June 2007.</p> </li> <li> <p>Compilation for Explicitly Managed Memory      Hierarchies.T. Knight, J. Park, M. Ren, M.      Houston, M. Erez, K. Fatahalian, A. Aiken, W. Dally, P. Hanrahan.      Proceedings of the Symposium on Principles and Practice of Parallel      Programming,pages 226-236, March 2007.</p> </li> <li> <p>Conditional Must Not Aliasing for Static Race      Detection.M. Naik and A. Aiken.Proceedings of      the ACM SIGPLAN Symposium on Principles of Programming      Languages,pages 327-338,January 2007.</p> </li> <li> <p>How is Aliasing Used in Systems Software?B.      Hackett and A. Aiken.Proceedings of the International Symposium on      Foundations of Software Engineering, pages 69-80, November 2006.</p> </li> <li> <p>Sequoia: Programming the Memory Hierarchy.K.      Fatahalian, T. Knight, M. Houston, M. Erez, D. Horn, L. Leem, H.      Park, M. Ren, A. Aiken, W. Dally and P. Hanrahan. Proceedings of      the Conference on Supercomputing, November 2006.</p> </li> <li> <p>Automatic Generation of Peephole      Superoptimizers.S. Bansal and A.      Aiken.Proceedings of the Conference on Architectural Support for      Programming Languages and Operating Systems,pages 394-403, October      2006.</p> </li> <li> <p>A Capability Calculus for Concurrency and      Determinism.T. Terauchi and A.      Aiken.Proceedings of the International Conference on Concurrency      Theory,pages 218-232, August 2006.</p> </li> <li> <p>On Typability for Rank-2 Intersection Types with Polymorphic      Recursion.T. Terauchi and A. Aiken.In      Proceedings of the 21st Annual IEEE Symposium on Logic in Computer      Science, pages 111-122, August 2006.</p> </li> <li> <p>Statistical Debugging: Simultaneous Identification of Multiple      Bugs.A. Zheng M. Jordan, B. Liblit, M. Naik      and A. Aiken.In Proceedings of the International Conference on      Machine Learning,pages 1105-1112, June 2006.</p> </li> <li> <p>Static Detection of Security Vulnerabilities in Scripting      Languages. Y. Xie and A. Aiken. In      Proceedings of the 15th USENIX Security Symposium, pages 179-192,      July 2006.</p> </li> <li> <p>Effective Static Race Detection for Java.M.      Naik, A. Aiken, and J. Whaley.In Proceedings of the ACM SIGPLAN      Conference on Programming Language Design and Implementation,pages      308-319, June 2006.</p> </li> <li> <p>Witnessing Side-Effects.T. Terauchi and A.      Aiken.In Proceedings of the 10th ACM SIGPLAN International      Conference on Functional Programming.pages 105-115, September      2005.</p> </li> <li> <p>Context- and Path-Sensitive Memory Leak      Detection. (distinguished paper award)Y. Xie      and A. Aiken.In Proceedings of the 5th Joint Meeting of the      European Software Engineering Conference and the ACM SIGSOFT      Symposium on the Foundations ofSoftware Engineering,pages 115-125,      September 2005.</p> </li> <li> <p>Banshee: A Scalable Constraint-Based Analysis      Toolkit.J. Kodumal and A. Aiken.In Proceedings      of the 12th International Static Analysis Symposium,pages 218-234,      September 2005.</p> </li> <li> <p>Secure Information Flow as a Safety Problem.T.      Terauchi and A. Aiken.In Proceedings of the 12th International      Static Analysis Symposium,pages 352-367, September 2005.</p> </li> <li> <p>Relational Queries Over Program Traces.S.      Goldsmith, R. O'Callahan, and A. Aiken.In Proceedings of the 2005      Conference on Object-Oriented Programming, Systems, Languages and      Applications,pages 385-402, October 2005.</p> </li> <li> <p>Saturn: A SAT-Based Tool for Bug Detection.Y.      Xie and A. Aiken.In Proceedings of the 17<sup>th</sup>      International Conference on Computer Aided Verification,pages      139-143, July 2005.</p> </li> <li> <p>Soundness and its Role in Bug Detection      Systems (position paper).Y. Xie, M. Naik, B.      Hackett, and A. Aiken.In Proceedings of the Workshop on the      Evaluation of Software Defect Detection Tools, June 2005.</p> </li> <li> <p>Scalable Statistical Bug Isolation. B.      Liblit, M. Naik, A. Zheng, A. Aiken and M. I. Jordan.In      Proceedings of the ACM SIGPLAN Conference on Programming Language      Design and Implementation,pages 15-26, June 2005.</p> </li> <li> <p>Scalable Error Detection using Boolean      Satisfiability.Y.      Xie and A. Aiken.Proceedings of the ACM SIGPLAN Symposium on      Principles of Programming Languages,p. 351-363,January 2005.</p> </li> <li> <p>The Set Constraint/CFL Reachability Connection in      Practice.J.      Kodumal and A. Aiken.In Proceedings of the ACM SIGPLAN Conference      on Programming Language Design and Implementation,pages      207-218,June 2004.</p> </li> <li> <p>Public Deployment of Cooperative Bug      Isolation. B.      Liblit, M. Naik, A. Zheng, A. Aiken, and M. I. Jordan.In      Proceedings of the Second International Workshop on Remote      Analysis and Measurement of Software Systems (RAMSS),pages 57-62,      May 2004.</p> </li> <li> <p>Statistical Debugging of Sampled Programs. A.  Zheng, M. I. Jordan, B. Liblit,      and A. Aiken.Advances in Neural Information Processing Systems 16 (NIPS),2004.</p> </li> <li> <p>Type Systems for Distributed Data Sharing.B.  Liblit, A. Aiken, and      K. Yelick. Proceedings of the 2003 Static Analysis Symposium,pages 273-294, June 2003.</p> </li> <li> <p>Sampling User Executions for Bug      Isolation. B.      Liblit, A. Aiken, A. Zheng, and M. I. Jordan.In Proceedings of the      First International Workshop on Remote Analysis and Measurement of      Software Systems (RAMSS),pages 5-8, May 2003.</p> </li> <li> <p>Bug Isolation via Remote Program      Sampling.B.      Liblit, A. Aiken, A. Zheng, and M. I. Jordan.In Proceedings of the      ACM SIGPLAN Conference on Programming Language Design and      Implementation,pages 141-154, June 2003.</p> </li> <li> <p>Checking and Inferring Local      Non-Aliasing.A.      Aiken, J. Foster, J. Kodumal, and T. Terauchi.Proceedings of the      ACM SIGPLAN Conference on Programming Language Design and      Implementation,pages 129-140, June 2003.</p> </li> <li> <p>Winnowing: Local Algorithms for Document      Fingerprinting.S.      Schleimer, D. Wilkerson, and A. Aiken.In Proceedings of the ACM      SIGMOD International Conference on Management of Data,pages 76-85,      June 2003.</p> </li> <li> <p>Flow-Sensitive Type      Qualifiers.J.      Foster, T. Terauchi, and A. Aiken.In Proceedings of the SIGPLAN      Conference on Programming Language Design and Implementation,pages      1-12, June 2002.</p> </li> <li> <p>First-Order Theory of Subtyping      Constraints.Z.      Su, A. Aiken, J. Niehren, T. Priesnitz, and R. Trienen.In      Proceedings of the ACM Symposium on Principles of Programming      Languages, pages 203-216, January 2002.</p> </li> <li> <p>Language Support for      Regions.D.      Gay and A. Aiken. In Proceedings of the SIGPLAN Conference on      Programming Language Design and Implementation,pages 70-80, June      2001.</p> </li> <li> <p>Entailment with Conditional Equality      Constraints, Z.      Su and A. Aiken. In Proceedings of the European Symposium on      Programming, pages 170-189, April 2001.</p> </li> <li> <p>Polymorphic versus Monomorphic Flow-Insensitive Points-to Analysis      for      C. J.      Foster, M. F\u00e4hndrich, and A. Aiken. In Proceedings of the 2000      Static Analysis Symposium, pages 175-198, June 2000.</p> </li> <li> <p>A First Step Towards Automated Detection of Buffer Overrun      Vulnerabilities.D.      Wagner, J. Foster, E. Brewer, and A. Aiken. In Proceedings of the      2000 Network and Distributed Systems Security Conference, pages      3-17, February 2000.</p> </li> <li> <p>Type Systems for Distributed Data      Structures. B.      Liblit and A. Aiken. Proceedings of the ACM Symposium on      Principles of Programming Languages, pages 199-213, January 2000.</p> </li> <li> <p>Projection Merging: Reducing Redundancies in Inclusion Constraint      Graphs.M.      F\u00e4hndrich, Z. Su, and A. Aiken. In Proceedings of the ACM      Symposium on Principles of Programming Languages, pages 81-95,      January 2000.</p> </li> <li> <p>A Theory of Type      Qualifiers. J.      Foster, M. F\u00e4hndrich, and A. Aiken. In Proceedings of the SIGPLAN      Conference on Programming Language Design and Implementation,pages      192-203, Atlanta, Georgia, June 1999.</p> </li> <li> <p>Partial Online Cycle Elimination in Inclusion Constraint      Graphs. M.      F\u00e4hndrich, J. Foster, Z. Su, and A. Aiken. In Proceedings of the      SIGPLAN Conference on Programming Language Design and      Implementation, pages 85-96, June 1998.</p> </li> <li> <p>Memory Management with Explicit      Regions. D.      Gay and A. Aiken.In Proceedings of the SIGPLAN Conference on      Programming Language Design and Implementation, pages 313-323,      June 1998.</p> </li> <li> <p>Detecting Races in Relay Ladder Logic      Programs.      (best paper award)A. Aiken, M. F\u00e4hndrich, and Z. Su. In      Proceedings of the 1st International Conference on Tools and      Algorithms for the Construction and Analysis of Systems, pages      184-200, April 1998.</p> </li> <li> <p>A Toolkit for Constructing Type- and Constraint-Based Program      Analyses      (invited paper).A. Aiken, M. F\u00e4hndrich, J. Foster, and Z. Su. In      Proceedings of the 2nd International Workshop on Types in      Compilation,LNCS #1473, pages 76-96, March 1998.</p> </li> <li> <p>Titanium: A High-Performance Java      Dialect.K.      Yelick, L. Semenzato, G. Pike, C. Miyamoto, B. Liblit, A.      Krishnamurthy, P. Hilfinger, S. Graham, D. Gay, P. Colella, and A.      Aiken. In Proceedings of the 1998 ACM Workshop on Java for High      Performance Computing,,pages 1-13, February, 1998.</p> </li> <li> <p>Attack Resistant Trust Metrics for Public Key      Certification. R.      Levien and A. Aiken.In Proceedings of the 7th USENIX Security      Symposium, pages 229-241, January, 1998.</p> </li> <li> <p>Barrier      Inference. D.      Gay and A. Aiken. In Proceedings of the Twenty-Fifth Annual ACM      Sigplan Symposium on Principles of Programming Languages, pages      342-354, January, 1998.</p> </li> <li> <p>Program Analysis Using Mixed Term and Set      Constraints. M.      F\u00e4hndrich and A. Aiken. In Proceedings of the 4th International      Static Analysis Symposium,pages 114-126, September, 1997.</p> </li> <li> <p>Optimal Representations of Polymorphic Types with Subtyping      (Extended      Abstract).A.      Aiken, E. Wimmers, and J. Palsberg.Theoretical Aspects of Computer      Software (TACS),September, 1997.</p> </li> <li> <p>Refined Type Inference for      ML. M.      F\u00e4hndrich and A. Aiken. In Proceedings of the 1st Workshop on      Types in Compilation,June 1997.</p> </li> <li> <p>Making Set-Constraint Program Analyses      Scale. M.      F\u00e4hndrich and A. Aiken. The CP'96 Workshop on Set Constraints,      August, 1996.Available as UC Berkeley Computer Science Technical      Report UCB//CSD-96-917.</p> </li> <li> <p>Tioga-2: A Direct Manipulation Database Visualization      Environment. A.      Aiken, J. Chen, M. Stonebraker, and A. Woodruff.Proceedings of the      12th International Conference on Data Engineering,pages 208-217,      February, 1996.</p> </li> <li> <p>The Tioga-2 Database Visualization      Environment. A.      Aiken, J. Chen, M. Lin, M. Spalding, M. Stonebraker, and A.      Woodruff.In Wierse, Grinstein and Lang (Eds.), Database Issues for      DataVisualization, IEEE Visualization '95 Workshop,October 1995      (LNCS v. 1183).</p> </li> <li> <p>Dynamic Typing vs. Subtype      Inference. A.      Aiken and M. F\u00e4hndrich. In Proceedings of the Eighth Conference on      Functional Programming and Computer Architecture,pages 182-191,      June 1995.</p> </li> <li> <p>Better Static Memory Management: Improvements to Region-Based      Analysis of Higher-Order      Languages. A.      Aiken, M. F\u00e4hndrich, and R. Levien. In Proceedings of the\u00a0 SIGPLAN      Conference on Programming Language Design and Implementation,pages      174-185, June 1995.Also available as Berkeley CS Report CSD-95-866.</p> </li> <li> <p>Navigation and Coordination Primitives for Multidimensional      Browsers.A.      Woodruff, A. Su, M. Stonebraker, C. Paxson, J. Chen, A. Aiken, P.      Wisnovsky, and C. Taylor. In Stefano Spaccapietra and Ramesh Jain      (Eds.), Visual Database Systems 3: Visual Information Management      (Proceedings of the 3rd IFIP 2.6 Working Conference on Visual      Database Systems), pages 360-371, March 1995, Chapman &amp; Hall.</p> </li> <li> <p>Zooming and Tunneling in Tioga: Supporting Navigation in      Multidimensional      Space.A.      Woodruff, P. Wisnovsky, C. Taylor, M. Stonebraker, C. Paxson, J.      Chen, and A. Aiken.In Proceedings of the IEEE Symposium on Visual      Languages,pages 191-193, October 1994.</p> </li> <li> <p>Directional Type Checking of Logic      Programs.A.      Aiken and T. K. Lakshman. In Proceedings of the 1st International      Static Analysis Symposium, pages 43-64, September 1994.</p> </li> <li> <p>Using the Run-Time Sizes of Data Structures to Guide Parallel      Thread      Creation.L.      Huelsbergen, J. Larus, and A. Aiken. In Proceedings of the 1994      Symposium on Lisp and Functional Programming, pages 79-90, June      1994.</p> </li> <li> <p>Set Constraints: Results, Applications, and Future      Directions. A.      Aiken. In Proceedings of the Second Workshop on the Principles and      Practice of Constraint Programming, pages 326-335, May 1994.</p> </li> <li> <p>Soft Typing with Conditional      Types. A.      Aiken, E. Wimmers, and T.K. Lakshman. In Proceedings of the      Twenty-First Annual ACM Symposium on Principles of Programming      Languages,pages 163-173, January 1994.</p> </li> <li> <p>The Complexity of Set      Constraints. A.      Aiken, D. Kozen, M. Vardi, and E. Wimmers. In Proceedings of      Computer Science Logic 1993, pages 1-17, September 1993.</p> </li> <li> <p>Type Inclusion Constraints and Type      Inference.A.      Aiken and E. Wimmers. In Proceedings of the Seventh ACM Conference      on Functional Programming and Computer Architecture,pages 31-41,      June 1993.</p> </li> <li> <p>Solving Systems of Set      Constraints. A.      Aiken and E. Wimmers. In Proceedings of the Seventh Annual IEEE      Symposium on Logic in Computer Science,pages 329-340, June 1992.</p> </li> <li> <p>Behavior of Database Production Rules: Termination, Confluence, and Observable      Determinism.A.  Aiken, J. Widom, and J. M. Hellerstein. In Proceedings      of the ACM SIGMOD International Conference on Management of Data, pages 59-68, June 1992.</p> </li> <li> <p>Implementing Regular Tree      Expressions. A.      Aiken and B. Murphy. In Proceedings of the Fifth ACM Conference on      Functional Programming and Computer Architecture, Lecture Notes in      Computer Science 523, pages 427-447, August 1991.</p> </li> <li> <p>Static Type Inference in a Dynamically Typed      Language.A.      Aiken and B. Murphy. In Proceedings of the Eighteenth Annual ACM      Symposium on Principles of Programming Languages,pages 279-290,      January 1991.</p> </li> <li> <p>Program Transformation in the Presence of      Errors. A.      Aiken, J. Williams, and E. Wimmers. In Proceedings of the      Seventeenth Annual ACM Symposium on Principles of Programming      Languages,pages 210-217, January 1990.</p> </li> <li> <p>Optimal Loop Parallelization.A.  Aiken and A. Nicolau.In Proceedings of      the SIGPLAN Conference on Programming Language Design and Implementation,pages 308-317, June      1988.</p> </li> <li> <p>Perfect Pipelining: A New Loop Parallelization      Technique. A.      Aiken and A. Nicolau.In Proceedings of the 1988 European Symposium      on Programming, Lecture Notes in Computer Science 300,pages      221-235, March 1988.</p> </li> <li> <p>A Development Environment for Horizontal         Microcode. A.      Aiken and A. Nicolau. In Proceedings of the Nineteenth Annual      Workshop on Microprogramming, pages 23-31, October 1986.</p> </li> </ol>"},{"location":"publications/#unrefereed-publications","title":"Unrefereed Publications","text":"<ol> <li>Report of the CRA Working Group on Research      Integrity.A.      Aiken, N. Amato, K. Bowling, L. De Floriano, E. Sturler, M.  Gini, V. Hanson, A. Krishnamurthy,      K. Larson, W. Li, M. Littman, F.  Ozcan, M. Russell, V. Sarkar, A. Schwartz, E. Spafford and D.      Srivastava. August 2023.</li> <li>Advice for Program      Chairs.A.      Aiken.ACM Sigplan Notices46(4), pages 19-25, April 2011.</li> <li>Cool: A Portable Project for Teaching Compiler      Construction.A.      Aiken.ACM Sigplan Notices31(7), pages 19-26, July 1996.</li> </ol>"},{"location":"publications/#technical-reports-not-published-elsewhere","title":"Technical Reports Not Published Elsewhere","text":"<ol> <li>The Sequoia++ User Manual.M.      Bauer, J. Clark, E. Schkufza, and A. AikenStanford University      Computer Science Technical Report, May 2010.</li> <li>Chord: A Static Analysis Framework for      Java.M. Naik and A. Aiken.Stanford      University Computer Science Technical Report, February 2008.</li> <li>The Saturn Program Analysis      System. A.      Aiken, S. Bugrara, I. Dillig, T. Dillig, B. Hackett, and P.      Hawkins. Stanford University Computer Science Technical Report,      December 2006.</li> <li>Building a Better Backtrace: Techniques for Postmortem Program      Analysis.B.      Liblit and A. Aiken.UC Berkeley Computer Science Technical Report      CSD-02-1203, October 2002.</li> <li>Tracking Down Exceptions in Standard ML      Programs.M.      F\u00e4hndrich, J. Foster, A. Aiken, and J. Cu. UC Berkeley Computer      Science Technical Report CSD-98-996, February 1998.</li> <li>FL Language Manual: Parts 1 and 2.J.  Backus, J. Williams, E. Wimmers,      P. Lucas, and A. Aiken. IBM Research Report RJ 7100, IBM Almaden Research Center,San Jose,      California, October 1989.</li> <li>The FL Project: The Design of a Functional      Language.A.      Aiken, J. Williams, and E. Wimmers.September, 1993.</li> <li>Compaction-Based Parallelization      (Ph.D. thesis).A. Aiken.Technical Report 88-922, Computer Science      Department, Cornell University, August 1988.</li> <li>Loop Quantization: An Analysis and      AlgorithmA.      Aiken and A. Nicolau.Technical Report 87-821, Computer Science      Department, Cornell University, March 1987.</li> </ol>"},{"location":"software/","title":"Software","text":""},{"location":"software/#alexs-software-page","title":"Alex's Software Page","text":"<p>I subscribe to the view that computer science researchers in the area of programming languages and software have two ways to disseminate their results. Papers are the means of communicating ideas to other specialists in the area, and implementations are the means of communicating ideas to non-specialists, in the form of tools they can use. My students and I probably devote more effort than is usual in translating our research into software that can be used by others.</p> <p>Here is a list of publicly available software systems with which I have been involved:</p> <ul> <li> <p>Lux is a system for high   performance distributed graph processing. Lux is built on top of   Legion.</p> </li> <li> <p>STOKE is a program   transformation/optimization system for X86 assembly based on   randomized search.</p> </li> <li> <p>Legion is a programming model for   heterogeneous and distributed parallel machines.</p> </li> <li> <p>Terra is a statically typed low-level   language that is integrated with and meta-programmed by Lua (a   dynamically typed high-level language). Terra provides support for   producing very high performance code using meta-programming   techniques.</p> </li> <li> <p>Mistral is   a SMT solver incorporating support for abductive inference and fast   solutions of integer linear constraints.</p> </li> <li> <p>Sixgill is a descendant of the Saturn   project aimed at analysis of large C/C++ systems. As might be   expected, sixgill shares some features with Saturn, but also takes a   new direction in being a near verifier, meaning that it is   designed to be sound and in principle can be made into a full   verifier if a few known soundness holes are plugged with more   analysis and any bugs in sixgill are fixed. Sixgill is also a   complete rewrite and shares no code with Saturn.</p> </li> <li> <p>SAIL is an   intermediate language designed for static analysis; it explicitly   both a high- and a low-level representation, with mappings between   them, to facilitate both analysis (on the low-level representation)   and reporting (through the high-level representation).</p> </li> <li> <p>Sequoia is a programming language   for hierarchical memory machines. A key feature of Sequoia is that   data locality is expressible directly in the language.</p> </li> <li> <p>Saturn is a second-generation   constraint-based analysis framework, primarily exploiting boolean   satisfiability as the underlying constraint language.</p> </li> <li> <p>Banshee, which is a descendant   of the earlier   BANE   project, is a framework for constructing efficient, scalable   constraint-based program analyses. Banshee has been used in a   variety of projects outside our group, including by gcc. UPDATE   2/2015:   Here is an   updated version of Banshee that builds on a current (as of 2015)   32-bit Ubuntu VM. Thank you Collin Gordon!</p> </li> <li> <p>Cooperative Bug Isolation (CBI) is   designed to leverage the power of thousands or millions of users to   help isolate bugs in deployed software systems.</p> </li> <li> <p>CQual is a tool for   adding type qualifiers to C programs to enable additional static   checking.</p> </li> <li> <p>Moss is a system for   efficiently detecting copies or partial copies of documents within a   large corpus. Moss, which was first developed in 1994 and released   in 1997, is widely used in engineering courses to help detect   plagiarism in programming assignments.</p> </li> <li> <p>CAP is a   descendant of Moss that provides a query interface to millions of   lines of open source software.</p> </li> <li> <p>Titanium is a   memory and type-safe explicitly parallel programming language based   on Java.</p> </li> <li> <p>Datasplash, a tool for   constructing database visualizations.</p> </li> <li> <p>Cool, the   Classroom Object Oriented Language , is a small language designed   for use in an undergraduate compiler course project. While small   enough for a one term project, Cool still has many of the features   of modern programming languages, including objects, inheritance, and   strong static typing.</p> <p>Cool is built entirely on public domain tools; it generates code for   a MIPS simulator, spim   . Thus, the project should port easily to other platforms. The   project has been used for teaching compilers at many institutions   around the world and the source code is available. The complete Cool   distribution includes the manual, source and makefiles for the   compiler, source and makefiles for each of the assignments, test   cases for each of the assignments, and lecture notes. Because the   project is still being used at Berkeley, only the manual is   available here. If you are interested in obtaining the complete   distribution, send mail to [aaiken@stanford.edu]{.kbd}.</p> </li> <li> <p>Illyria was finished in 1994 and is still on this page just for   historical reasons.</p> <p>Illyria is a small functional   language designed to illustrate a subtype inference system based on   solving systems of type inclusion constraints. Illyria includes the   lambda calculus, polymorphic let, constructors, case expressions,   and record operations. The type language is rich, with union,   intersection, complement, conditional, recursive, and universally   quantified types. This package includes the type inclusion   constraint solver, type inference for Illyria, and examples.</p> <p>Illyria runs under Common Lisp on Unix systems. The only known   problem is that Illyria does not compile under CMU Common Lisp,   although it will run interpreted in that environment. After   retrieving the package, do:   </p><pre><code>gunzip Illyria.tar.gz\nmv Illyria.tar dir/.\ncd dir\ntar -xvf Illyria.tar\n</code></pre>   See the instructions in the Illyria/README file.<p></p> </li> </ul>"},{"location":"software/cool/cool/","title":"Cool: The Classroom Object-Oriented Language","text":""},{"location":"software/cool/cool/#cool-the-classroom-object-oriented-language","title":"Cool: The Classroom Object-Oriented Language","text":"<p>Cool is a small language designed for use in an undergraduate compiler course project. While small enough for a one term project, Cool still has many of the features of modern programming languages, including objects, automatic memory management, and strong static typing. Cool is built entirely on public domain tools; it generates code for a MIPS simulator, spim . Thus, the project should port easily to other platforms. The project has been used for teaching compilers at many institutions and the software is stable.</p> <p>The complete Cool distribution includes the manual, source and makefiles for the compiler, source and makefiles for each of the assignments, and regression tests. Instructors can obtain the complete distribution by sending mail to aiken@cs.stanford.edu.</p> <p>A student distribution of the project is available. These distributions include object code for the coolc reference compiler, assignments, and all documentation. The only components omitted are source for the reference compiler and the regression tests.</p> <p>A longer description of the Cool compiler project is available, as are the manual and (on request) lecture notes from a course that used Cool.</p>"},{"location":"software/cooldist/assignments/","title":"Index of /~aiken/software/cooldist/assignments","text":""},{"location":"software/cooldist/assignments/#index-of-aikensoftwarecooldistassignments","title":"Index of /~aiken/software/cooldist/assignments","text":"Name Last modified Size Description Parent Directory - PA1/ 24-Sep-2009 18:11 - PA2/ 24-Sep-2009 18:11 - PA2J/ 24-Sep-2009 18:11 - PA3/ 18-Oct-2009 21:16 - PA3J/ 04-Oct-2009 16:05 - PA4/ 03-Nov-2009 23:22 - PA4J/ 18-Oct-2009 21:32 - PA5/ 11-Nov-2009 13:07 - PA5J/ 24-Sep-2009 18:11 -"},{"location":"software/cooldist/assignments/PA1/","title":"Index of /~aiken/software/cooldist/assignments/PA1","text":""},{"location":"software/cooldist/assignments/PA1/#index-of-aikensoftwarecooldistassignmentspa1","title":"Index of /~aiken/software/cooldist/assignments/PA1","text":"Name Last modified Size Description Parent Directory - Makefile 24-Sep-2009 18:11 480 Makefile.SKEL 24-Sep-2009 14:12 446 atoi.cl 24-Sep-2009 14:12 2.7K stack.cl.SKEL 24-Sep-2009 14:12 226 stack.test 24-Sep-2009 14:12 50"},{"location":"software/cooldist/assignments/PA2/","title":"Index of /~aiken/software/cooldist/assignments/PA2","text":""},{"location":"software/cooldist/assignments/PA2/#index-of-aikensoftwarecooldistassignmentspa2","title":"Index of /~aiken/software/cooldist/assignments/PA2","text":"Name Last modified Size Description Parent Directory - Makefile 24-Sep-2009 18:11 1.6K Makefile.SKEL 24-Sep-2009 17:56 1.6K cool.flex.SKEL 24-Sep-2009 17:56 1.6K test.cl.SKEL 24-Sep-2009 17:56 2.4K"},{"location":"software/cooldist/assignments/PA2J/","title":"Index of /~aiken/software/cooldist/assignments/PA2J","text":""},{"location":"software/cooldist/assignments/PA2J/#index-of-aikensoftwarecooldistassignmentspa2j","title":"Index of /~aiken/software/cooldist/assignments/PA2J","text":"Name Last modified Size Description Parent Directory - BoolConst.java.SKEL 24-Sep-2009 14:12 2.7K Makefile 24-Sep-2009 18:11 1.8K Makefile.SKEL 24-Sep-2009 14:12 1.7K cool.lex.SKEL 24-Sep-2009 14:12 2.3K cool.lex.SKEL.bak 24-Sep-2009 14:12 2.7K test.cl.SKEL 24-Sep-2009 14:12 2.4K"},{"location":"software/cooldist/assignments/PA3/","title":"Index of /~aiken/software/cooldist/assignments/PA3","text":""},{"location":"software/cooldist/assignments/PA3/#index-of-aikensoftwarecooldistassignmentspa3","title":"Index of /~aiken/software/cooldist/assignments/PA3","text":"Name Last modified Size Description Parent Directory - Makefile 18-Oct-2009 21:16 2.1K Makefile.SKEL 18-Oct-2009 21:16 2.0K bad.cl.SKEL 24-Sep-2009 14:12 481 cool-tree.handcode.h.SKEL 24-Sep-2009 14:12 2.8K cool.y.SKEL 24-Sep-2009 14:12 3.6K good.cl.SKEL 12-Oct-2009 18:47 81"},{"location":"software/cooldist/assignments/PA3J/","title":"Index of /~aiken/software/cooldist/assignments/PA3J","text":""},{"location":"software/cooldist/assignments/PA3J/#index-of-aikensoftwarecooldistassignmentspa3j","title":"Index of /~aiken/software/cooldist/assignments/PA3J","text":"Name Last modified Size Description Parent Directory - Makefile 04-Oct-2009 14:59 2.4K Makefile.SKEL 24-Sep-2009 14:12 2.3K bad.cl.SKEL 24-Sep-2009 14:12 484 cool.cup.SKEL 04-Oct-2009 16:05 3.1K good.cl.SKEL 24-Sep-2009 14:12 41"},{"location":"software/cooldist/assignments/PA4/","title":"Index of /~aiken/software/cooldist/assignments/PA4","text":""},{"location":"software/cooldist/assignments/PA4/#index-of-aikensoftwarecooldistassignmentspa4","title":"Index of /~aiken/software/cooldist/assignments/PA4","text":"Name Last modified Size Description Parent Directory - Makefile 18-Oct-2009 21:16 2.3K Makefile.SKEL 18-Oct-2009 21:13 2.2K bad.cl.SKEL 24-Sep-2009 14:12 251 cool-tree.h.SKEL 24-Sep-2009 14:12 16K cool-tree.handcode.h.SKEL 24-Sep-2009 14:12 2.8K good.cl.SKEL 24-Sep-2009 14:12 180 semant.cc.SKEL 18-Oct-2009 21:12 8.0K semant.h.SKEL 24-Sep-2009 14:12 778"},{"location":"software/cooldist/assignments/PA4J/","title":"Index of /~aiken/software/cooldist/assignments/PA4J","text":""},{"location":"software/cooldist/assignments/PA4J/#index-of-aikensoftwarecooldistassignmentspa4j","title":"Index of /~aiken/software/cooldist/assignments/PA4J","text":"Name Last modified Size Description Parent Directory - ClassTable.java.SKEL 24-Sep-2009 14:12 6.9K Makefile 24-Sep-2009 18:11 2.3K Makefile.SKEL 24-Sep-2009 14:12 2.2K TreeConstants.java.SKEL 24-Sep-2009 14:12 2.6K bad.cl.SKEL 24-Sep-2009 14:12 251 cool-tree.java.SKEL 18-Oct-2009 21:32 41K good.cl.SKEL 24-Sep-2009 14:12 180"},{"location":"software/cooldist/assignments/PA5/","title":"Index of /~aiken/software/cooldist/assignments/PA5","text":""},{"location":"software/cooldist/assignments/PA5/#index-of-aikensoftwarecooldistassignmentspa5","title":"Index of /~aiken/software/cooldist/assignments/PA5","text":"Name Last modified Size Description Parent Directory - Makefile 03-Nov-2009 23:24 2.2K Makefile.SKEL 24-Sep-2009 14:12 2.0K cgen.cc.SKEL 11-Nov-2009 13:07 26K cgen.h.SKEL 24-Sep-2009 14:12 1.9K cgen_supp.cc.SKEL 24-Sep-2009 14:12 1.0K cool-tree.h.SKEL 24-Sep-2009 14:12 16K cool-tree.handcode.h.SKEL 24-Sep-2009 14:12 3.1K emit.h.SKEL 24-Sep-2009 14:12 2.9K example.cl.SKEL 24-Sep-2009 14:12 131"},{"location":"software/cooldist/assignments/PA5J/","title":"Index of /~aiken/software/cooldist/assignments/PA5J","text":""},{"location":"software/cooldist/assignments/PA5J/#index-of-aikensoftwarecooldistassignmentspa5j","title":"Index of /~aiken/software/cooldist/assignments/PA5J","text":"Name Last modified Size Description Parent Directory - BoolConst.java.SKEL 24-Sep-2009 14:12 2.7K CgenClassTable.java.SKEL 24-Sep-2009 14:12 14K CgenNode.java.SKEL 24-Sep-2009 14:12 2.8K CgenSupport.java.SKEL 24-Sep-2009 14:12 18K IntSymbol.java.SKEL 24-Sep-2009 14:12 2.4K Makefile 24-Sep-2009 18:11 2.2K Makefile.SKEL 24-Sep-2009 14:12 2.2K StringSymbol.java.SKEL 24-Sep-2009 14:12 2.6K TreeConstants.java.SKEL 24-Sep-2009 14:12 3.6K cool-tree.java.SKEL 24-Sep-2009 14:12 48K example.cl.SKEL 24-Sep-2009 14:12 131"},{"location":"software/cooldist/bin/","title":"Index of /~aiken/software/cooldist/bin","text":""},{"location":"software/cooldist/bin/#index-of-aikensoftwarecooldistbin","title":"Index of /~aiken/software/cooldist/bin","text":"Name Last modified Size Description Parent Directory - aps2c++ 24-Sep-2009 18:11 888 aps2java 24-Sep-2009 14:13 224K coolc 24-Sep-2009 18:11 884 dispatch.SKEL 24-Sep-2009 14:12 888 spim 24-Sep-2009 18:11 882 xspim 24-Sep-2009 18:11 884"},{"location":"software/cooldist/doc/","title":"Index of /~aiken/software/cooldist/doc","text":""},{"location":"software/cooldist/doc/#index-of-aikensoftwarecooldistdoc","title":"Index of /~aiken/software/cooldist/doc","text":"Name Last modified Size Description Parent Directory - bison.ps.gz 24-Sep-2009 14:12 127K flex.ps.gz 24-Sep-2009 14:12 79K make.ps.gz 24-Sep-2009 14:12 215K spim.ps.gz 24-Sep-2009 14:12 117K"},{"location":"software/cooldist/etc/","title":"Index of /~aiken/software/cooldist/etc","text":""},{"location":"software/cooldist/etc/#index-of-aikensoftwarecooldistetc","title":"Index of /~aiken/software/cooldist/etc","text":"Name Last modified Size Description Parent Directory - copy-skel 24-Sep-2009 18:11 1.9K copy-skel.SKEL 24-Sep-2009 14:12 1.8K link-object 24-Sep-2009 18:11 2.0K link-object.SKEL 24-Sep-2009 14:12 1.9K link-shared 24-Sep-2009 18:11 1.9K link-shared.SKEL 24-Sep-2009 14:12 1.8K"},{"location":"software/cooldist/examples/","title":"Index of /~aiken/software/cooldist/examples","text":""},{"location":"software/cooldist/examples/#index-of-aikensoftwarecooldistexamples","title":"Index of /~aiken/software/cooldist/examples","text":"Name Last modified Size Description Parent Directory - arith.cl 24-Sep-2009 14:12 10K atoi.cl 24-Sep-2009 14:12 2.7K atoi_test.cl 24-Sep-2009 14:12 1.0K book_list.cl 24-Sep-2009 14:12 3.4K cells.cl 24-Sep-2009 14:12 2.4K complex.cl 24-Sep-2009 14:12 707 cool.cl 24-Sep-2009 14:12 200 g1.graph 24-Sep-2009 14:12 74 graph.cl 24-Sep-2009 14:12 7.5K hairyscary.cl 24-Sep-2009 14:12 1.0K hello_world.cl 24-Sep-2009 14:12 88 io.cl 24-Sep-2009 14:12 2.3K lam.cl 24-Sep-2009 14:12 10K life.cl 24-Sep-2009 14:12 9.9K list.cl 24-Sep-2009 14:12 3.9K new_complex.cl 24-Sep-2009 14:12 1.1K palindrome.cl 24-Sep-2009 14:12 488 primes.cl 24-Sep-2009 14:12 2.7K sort_list.cl 24-Sep-2009 14:12 3.1K"},{"location":"software/cooldist/handouts/","title":"Index of /~aiken/software/cooldist/handouts","text":""},{"location":"software/cooldist/handouts/#index-of-aikensoftwarecooldisthandouts","title":"Index of /~aiken/software/cooldist/handouts","text":"Name Last modified Size Description Parent Directory - PA1.pdf 19-Feb-2010 23:38 98K PA2.pdf 19-Feb-2010 23:38 70K PA3.pdf 19-Feb-2010 23:38 85K PA4.pdf 19-Feb-2010 23:38 83K PAX.pdf 19-Feb-2010 23:38 64K asn2.pdf 19-Feb-2010 23:38 88K asn3.pdf 19-Feb-2010 23:38 73K asn4.pdf 19-Feb-2010 23:38 89K asn5.pdf 19-Feb-2010 23:38 83K asnx.pdf 19-Feb-2010 23:38 64K cool-manual.pdf 19-Feb-2010 23:38 221K cool-runtime.pdf 19-Feb-2010 23:38 91K cool-tour.pdf 19-Feb-2010 23:38 148K coolaid-manual.pdf 19-Feb-2010 23:38 268K"},{"location":"software/cooldist/include/","title":"Index of /~aiken/software/cooldist/include","text":""},{"location":"software/cooldist/include/#index-of-aikensoftwarecooldistinclude","title":"Index of /~aiken/software/cooldist/include","text":"Name Last modified Size Description Parent Directory - PA1/ 24-Sep-2009 14:12 - PA2/ 24-Sep-2009 17:56 - PA2J/ 24-Sep-2009 14:12 - PA3/ 24-Sep-2009 17:56 - PA3J/ 24-Sep-2009 14:12 - PA4/ 18-Oct-2009 21:03 - PA4J/ 24-Sep-2009 14:12 - PA5/ 24-Sep-2009 17:56 - PA5J/ 24-Sep-2009 14:12 -"},{"location":"software/cooldist/include/PA1/","title":"Index of /~aiken/software/cooldist/include/PA1","text":""},{"location":"software/cooldist/include/PA1/#index-of-aikensoftwarecooldistincludepa1","title":"Index of /~aiken/software/cooldist/include/PA1","text":"Name Last modified Size Description Parent Directory -"},{"location":"software/cooldist/include/PA2/","title":"Index of /~aiken/software/cooldist/include/PA2","text":""},{"location":"software/cooldist/include/PA2/#index-of-aikensoftwarecooldistincludepa2","title":"Index of /~aiken/software/cooldist/include/PA2","text":"Name Last modified Size Description Parent Directory - cgen_gc.h 24-Sep-2009 14:14 375 cool-io.h 24-Sep-2009 14:14 942 cool-parse.h 24-Sep-2009 17:56 4.8K cool.h 24-Sep-2009 14:14 485 copyright.h 24-Sep-2009 14:14 1.0K list.h 24-Sep-2009 14:14 1.7K stringtab.h 24-Sep-2009 14:14 3.7K stringtab_functions.h 24-Sep-2009 14:14 2.4K tree.h 24-Sep-2009 14:14 12K utilities.h 24-Sep-2009 14:14 531"},{"location":"software/cooldist/include/PA2J/","title":"Index of /~aiken/software/cooldist/include/PA2J","text":""},{"location":"software/cooldist/include/PA2J/#index-of-aikensoftwarecooldistincludepa2j","title":"Index of /~aiken/software/cooldist/include/PA2J","text":"Name Last modified Size Description Parent Directory -"},{"location":"software/cooldist/include/PA3/","title":"Index of /~aiken/software/cooldist/include/PA3","text":""},{"location":"software/cooldist/include/PA3/#index-of-aikensoftwarecooldistincludepa3","title":"Index of /~aiken/software/cooldist/include/PA3","text":"Name Last modified Size Description Parent Directory - cgen_gc.h 24-Sep-2009 14:14 375 cool-io.h 24-Sep-2009 14:14 942 cool-parse.h 24-Sep-2009 17:56 4.8K cool-tree.h 24-Sep-2009 17:56 16K cool.h 24-Sep-2009 14:14 485 copyright.h 24-Sep-2009 14:14 1.0K list.h 24-Sep-2009 14:14 1.7K stringtab.h 24-Sep-2009 14:14 3.7K stringtab_functions.h 24-Sep-2009 14:14 2.4K tree.h 24-Sep-2009 14:14 12K utilities.h 24-Sep-2009 14:14 531"},{"location":"software/cooldist/include/PA3J/","title":"Index of /~aiken/software/cooldist/include/PA3J","text":""},{"location":"software/cooldist/include/PA3J/#index-of-aikensoftwarecooldistincludepa3j","title":"Index of /~aiken/software/cooldist/include/PA3J","text":"Name Last modified Size Description Parent Directory -"},{"location":"software/cooldist/include/PA4/","title":"Index of /~aiken/software/cooldist/include/PA4","text":""},{"location":"software/cooldist/include/PA4/#index-of-aikensoftwarecooldistincludepa4","title":"Index of /~aiken/software/cooldist/include/PA4","text":"Name Last modified Size Description Parent Directory - ast-parse.h 24-Sep-2009 17:56 4.7K cgen_gc.h 18-Oct-2009 21:03 375 cool-io.h 18-Oct-2009 21:03 942 cool-parse.h 18-Oct-2009 21:03 4.8K cool-tree.h 18-Oct-2009 21:03 16K cool.h 18-Oct-2009 21:03 485 copyright.h 18-Oct-2009 21:03 1.0K list.h 18-Oct-2009 21:03 1.7K stringtab.h 18-Oct-2009 21:03 3.7K stringtab_functions.h 18-Oct-2009 21:03 2.4K symtab.h 24-Sep-2009 14:14 5.1K tree.h 18-Oct-2009 21:03 12K utilities.h 18-Oct-2009 21:03 531"},{"location":"software/cooldist/include/PA4J/","title":"Index of /~aiken/software/cooldist/include/PA4J","text":""},{"location":"software/cooldist/include/PA4J/#index-of-aikensoftwarecooldistincludepa4j","title":"Index of /~aiken/software/cooldist/include/PA4J","text":"Name Last modified Size Description Parent Directory -"},{"location":"software/cooldist/include/PA5/","title":"Index of /~aiken/software/cooldist/include/PA5","text":""},{"location":"software/cooldist/include/PA5/#index-of-aikensoftwarecooldistincludepa5","title":"Index of /~aiken/software/cooldist/include/PA5","text":"Name Last modified Size Description Parent Directory - ast-parse.h 24-Sep-2009 17:56 4.7K cgen_gc.h 24-Sep-2009 14:14 375 cool-io.h 24-Sep-2009 14:14 942 cool-parse.h 24-Sep-2009 17:56 4.8K cool-tree.h 24-Sep-2009 17:56 16K cool.h 24-Sep-2009 14:14 485 copyright.h 24-Sep-2009 14:14 1.0K list.h 24-Sep-2009 14:14 1.7K stringtab.h 24-Sep-2009 14:14 3.7K stringtab_functions.h 24-Sep-2009 14:14 2.4K symtab.h 24-Sep-2009 14:14 5.1K tree.h 24-Sep-2009 14:14 12K utilities.h 24-Sep-2009 14:14 531"},{"location":"software/cooldist/include/PA5J/","title":"Index of /~aiken/software/cooldist/include/PA5J","text":""},{"location":"software/cooldist/include/PA5J/#index-of-aikensoftwarecooldistincludepa5j","title":"Index of /~aiken/software/cooldist/include/PA5J","text":"Name Last modified Size Description Parent Directory -"},{"location":"software/cooldist/lib/","title":"Index of /~aiken/software/cooldist/lib","text":""},{"location":"software/cooldist/lib/#index-of-aikensoftwarecooldistlib","title":"Index of /~aiken/software/cooldist/lib","text":"Name Last modified Size Description Parent Directory - META-INF/ 04-Oct-2009 15:35 - PA1/ 24-Sep-2009 14:13 - PA1J/ 24-Sep-2009 14:14 - PA2/ 24-Sep-2009 14:14 - PA2J/ 24-Sep-2009 14:14 - PA3/ 24-Sep-2009 14:14 - PA3J/ 24-Sep-2009 14:14 - PA4/ 24-Sep-2009 14:14 - PA4J/ 24-Sep-2009 14:14 - PA5/ 24-Sep-2009 14:14 - PA5J/ 24-Sep-2009 14:14 - PA6/ 24-Sep-2009 14:13 - cgen 24-Sep-2009 14:14 1.5M java-cup-11a.jar 24-Sep-2009 18:21 94K java_cup/ 04-Oct-2009 15:35 - jlex.jar 24-Sep-2009 18:21 50K lexer 24-Sep-2009 14:14 1.5M parser 24-Sep-2009 14:13 1.5M semant 24-Sep-2009 14:14 1.5M trap.handler 24-Sep-2009 18:21 78K trap.handler.gc 24-Sep-2009 18:21 97K trap.handler.nogc 24-Sep-2009 18:21 19K trap.handler.quiet 24-Sep-2009 18:21 76K"},{"location":"software/cooldist/lib/META-INF/","title":"Index of /~aiken/software/cooldist/lib/META-INF","text":""},{"location":"software/cooldist/lib/META-INF/#index-of-aikensoftwarecooldistlibmeta-inf","title":"Index of /~aiken/software/cooldist/lib/META-INF","text":"Name Last modified Size Description Parent Directory - MANIFEST.MF 04-Oct-2009 15:35 171"},{"location":"software/cooldist/lib/PA1/","title":"Index of /~aiken/software/cooldist/lib/PA1","text":""},{"location":"software/cooldist/lib/PA1/#index-of-aikensoftwarecooldistlibpa1","title":"Index of /~aiken/software/cooldist/lib/PA1","text":"Name Last modified Size Description Parent Directory -"},{"location":"software/cooldist/lib/PA1J/","title":"Index of /~aiken/software/cooldist/lib/PA1J","text":""},{"location":"software/cooldist/lib/PA1J/#index-of-aikensoftwarecooldistlibpa1j","title":"Index of /~aiken/software/cooldist/lib/PA1J","text":"Name Last modified Size Description Parent Directory -"},{"location":"software/cooldist/lib/PA2/","title":"Index of /~aiken/software/cooldist/lib/PA2","text":""},{"location":"software/cooldist/lib/PA2/#index-of-aikensoftwarecooldistlibpa2","title":"Index of /~aiken/software/cooldist/lib/PA2","text":"Name Last modified Size Description Parent Directory - cgen 24-Sep-2009 14:14 1.5M parser 24-Sep-2009 14:13 1.5M semant 24-Sep-2009 14:14 1.5M"},{"location":"software/cooldist/lib/PA2J/","title":"Index of /~aiken/software/cooldist/lib/PA2J","text":""},{"location":"software/cooldist/lib/PA2J/#index-of-aikensoftwarecooldistlibpa2j","title":"Index of /~aiken/software/cooldist/lib/PA2J","text":"Name Last modified Size Description Parent Directory - cgen 24-Sep-2009 14:14 1.5M parser 24-Sep-2009 14:13 1.5M semant 24-Sep-2009 14:14 1.5M"},{"location":"software/cooldist/lib/PA3/","title":"Index of /~aiken/software/cooldist/lib/PA3","text":""},{"location":"software/cooldist/lib/PA3/#index-of-aikensoftwarecooldistlibpa3","title":"Index of /~aiken/software/cooldist/lib/PA3","text":"Name Last modified Size Description Parent Directory - cgen 24-Sep-2009 14:14 1.5M lexer 24-Sep-2009 14:14 1.5M semant 24-Sep-2009 14:14 1.5M"},{"location":"software/cooldist/lib/PA3J/","title":"Index of /~aiken/software/cooldist/lib/PA3J","text":""},{"location":"software/cooldist/lib/PA3J/#index-of-aikensoftwarecooldistlibpa3j","title":"Index of /~aiken/software/cooldist/lib/PA3J","text":"Name Last modified Size Description Parent Directory - cgen 24-Sep-2009 14:14 1.5M lexer 24-Sep-2009 14:14 1.5M semant 24-Sep-2009 14:14 1.5M"},{"location":"software/cooldist/lib/PA4/","title":"Index of /~aiken/software/cooldist/lib/PA4","text":""},{"location":"software/cooldist/lib/PA4/#index-of-aikensoftwarecooldistlibpa4","title":"Index of /~aiken/software/cooldist/lib/PA4","text":"Name Last modified Size Description Parent Directory - cgen 24-Sep-2009 14:14 1.5M lexer 24-Sep-2009 14:14 1.5M parser 24-Sep-2009 14:13 1.5M"},{"location":"software/cooldist/lib/PA4J/","title":"Index of /~aiken/software/cooldist/lib/PA4J","text":""},{"location":"software/cooldist/lib/PA4J/#index-of-aikensoftwarecooldistlibpa4j","title":"Index of /~aiken/software/cooldist/lib/PA4J","text":"Name Last modified Size Description Parent Directory - cgen 24-Sep-2009 14:14 1.5M lexer 24-Sep-2009 14:14 1.5M parser 24-Sep-2009 14:13 1.5M"},{"location":"software/cooldist/lib/PA5/","title":"Index of /~aiken/software/cooldist/lib/PA5","text":""},{"location":"software/cooldist/lib/PA5/#index-of-aikensoftwarecooldistlibpa5","title":"Index of /~aiken/software/cooldist/lib/PA5","text":"Name Last modified Size Description Parent Directory - lexer 24-Sep-2009 14:14 1.5M parser 24-Sep-2009 14:13 1.5M semant 24-Sep-2009 14:14 1.5M"},{"location":"software/cooldist/lib/PA5J/","title":"Index of /~aiken/software/cooldist/lib/PA5J","text":""},{"location":"software/cooldist/lib/PA5J/#index-of-aikensoftwarecooldistlibpa5j","title":"Index of /~aiken/software/cooldist/lib/PA5J","text":"Name Last modified Size Description Parent Directory - lexer 24-Sep-2009 14:14 1.5M parser 24-Sep-2009 14:13 1.5M semant 24-Sep-2009 14:14 1.5M"},{"location":"software/cooldist/lib/PA6/","title":"Index of /~aiken/software/cooldist/lib/PA6","text":""},{"location":"software/cooldist/lib/PA6/#index-of-aikensoftwarecooldistlibpa6","title":"Index of /~aiken/software/cooldist/lib/PA6","text":"Name Last modified Size Description Parent Directory -"},{"location":"software/cooldist/lib/java_cup/","title":"Index of /~aiken/software/cooldist/lib/java_cup","text":""},{"location":"software/cooldist/lib/java_cup/#index-of-aikensoftwarecooldistlibjava_cup","title":"Index of /~aiken/software/cooldist/lib/java_cup","text":"Name Last modified Size Description Parent Directory - CUP$parser$actions.class 04-Oct-2009 15:35 20K ErrorManager.class 04-Oct-2009 15:35 3.3K Lexer.class 04-Oct-2009 15:35 15K Main.class 04-Oct-2009 15:35 17K action_part.class 04-Oct-2009 15:35 1.4K action_production.class 04-Oct-2009 15:35 1.0K anttask/ 04-Oct-2009 15:35 - assoc.class 04-Oct-2009 15:35 398 emit.class 04-Oct-2009 15:35 16K internal_error.class 04-Oct-2009 15:35 852 lalr_item.class 04-Oct-2009 15:35 4.4K lalr_item_set.class 04-Oct-2009 15:35 4.8K lalr_state.class 04-Oct-2009 15:35 12K lalr_transition.class 04-Oct-2009 15:35 1.7K lr_item_core.class 04-Oct-2009 15:35 3.7K non_terminal.class 04-Oct-2009 15:35 4.6K nonassoc_action.class 04-Oct-2009 15:35 915 parse_action.class 04-Oct-2009 15:35 951 parse_action_row.class 04-Oct-2009 15:35 1.2K parse_action_table.class 04-Oct-2009 15:35 2.5K parse_reduce_row.class 04-Oct-2009 15:35 660 parse_reduce_table.class 04-Oct-2009 15:35 1.5K parser.class 04-Oct-2009 15:35 9.3K production.class 04-Oct-2009 15:35 9.8K production_part.class 04-Oct-2009 15:35 1.2K reduce_action.class 04-Oct-2009 15:35 1.4K runtime/ 04-Oct-2009 15:35 - shift_action.class 04-Oct-2009 15:35 1.4K sym.class 04-Oct-2009 15:35 2.9K symbol.class 04-Oct-2009 15:35 1.1K symbol_part.class 04-Oct-2009 15:35 1.7K symbol_set.class 04-Oct-2009 15:35 3.3K terminal.class 04-Oct-2009 15:35 2.7K terminal_set.class 04-Oct-2009 15:35 3.0K version.class 04-Oct-2009 15:35 688"},{"location":"software/cooldist/lib/java_cup/anttask/","title":"Index of /~aiken/software/cooldist/lib/java_cup/anttask","text":""},{"location":"software/cooldist/lib/java_cup/anttask/#index-of-aikensoftwarecooldistlibjava_cupanttask","title":"Index of /~aiken/software/cooldist/lib/java_cup/anttask","text":"Name Last modified Size Description Parent Directory - CUPTask.class 04-Oct-2009 15:35 9.3K"},{"location":"software/cooldist/lib/java_cup/runtime/","title":"Index of /~aiken/software/cooldist/lib/java_cup/runtime","text":""},{"location":"software/cooldist/lib/java_cup/runtime/#index-of-aikensoftwarecooldistlibjava_cupruntime","title":"Index of /~aiken/software/cooldist/lib/java_cup/runtime","text":"Name Last modified Size Description Parent Directory - ComplexSymbolFactory$ComplexSymbol.class 04-Oct-2009 15:35 2.8K ComplexSymbolFactory$Location.class 04-Oct-2009 15:35 1.2K ComplexSymbolFactory.class 04-Oct-2009 15:35 2.7K DefaultSymbolFactory.class 04-Oct-2009 15:35 2.0K ParserException.class 04-Oct-2009 15:35 376 Scanner.class 04-Oct-2009 15:35 211 Symbol.class 04-Oct-2009 15:35 1.7K SymbolFactory.class 04-Oct-2009 15:35 572 lr_parser.class 04-Oct-2009 15:35 12K virtual_parse_stack.class 04-Oct-2009 15:35 1.7K"},{"location":"software/cooldist/src/","title":"Index of /~aiken/software/cooldist/src","text":""},{"location":"software/cooldist/src/#index-of-aikensoftwarecooldistsrc","title":"Index of /~aiken/software/cooldist/src","text":"Name Last modified Size Description Parent Directory - PA1/ 24-Sep-2009 14:12 - PA2/ 24-Sep-2009 14:14 - PA2J/ 24-Sep-2009 14:14 - PA3/ 04-Oct-2009 14:30 - PA3J/ 18-Oct-2009 21:31 - PA4/ 18-Oct-2009 21:05 - PA4J/ 18-Oct-2009 21:28 - PA5/ 03-Nov-2009 17:15 - PA5J/ 03-Nov-2009 18:40 -"},{"location":"software/cooldist/src/PA1/","title":"Index of /~aiken/software/cooldist/src/PA1","text":""},{"location":"software/cooldist/src/PA1/#index-of-aikensoftwarecooldistsrcpa1","title":"Index of /~aiken/software/cooldist/src/PA1","text":"Name Last modified Size Description Parent Directory -"},{"location":"software/cooldist/src/PA2/","title":"Index of /~aiken/software/cooldist/src/PA2","text":""},{"location":"software/cooldist/src/PA2/#index-of-aikensoftwarecooldistsrcpa2","title":"Index of /~aiken/software/cooldist/src/PA2","text":"Name Last modified Size Description Parent Directory - handle_flags.cc 24-Sep-2009 14:14 3.2K lextest.cc 24-Sep-2009 14:14 2.5K mycoolc 24-Sep-2009 14:14 65 stringtab.cc 24-Sep-2009 14:14 1.7K utilities.cc 24-Sep-2009 14:14 7.0K"},{"location":"software/cooldist/src/PA2J/","title":"Index of /~aiken/software/cooldist/src/PA2J","text":""},{"location":"software/cooldist/src/PA2J/#index-of-aikensoftwarecooldistsrcpa2j","title":"Index of /~aiken/software/cooldist/src/PA2J","text":"Name Last modified Size Description Parent Directory - AbstractSymbol.java 24-Sep-2009 14:14 3.6K AbstractTable.java 24-Sep-2009 14:14 7.2K BoolConst.java 24-Sep-2009 14:14 2.7K CgenSupport.java 24-Sep-2009 14:14 18K ClassTable.java 24-Sep-2009 14:14 8.3K Flags.java 24-Sep-2009 14:14 4.1K IdSymbol.java 24-Sep-2009 14:14 1.4K IdTable.java 24-Sep-2009 14:14 1.2K IntSymbol.java 24-Sep-2009 14:14 2.4K IntTable.java 24-Sep-2009 14:14 1.7K Lexer.java 24-Sep-2009 14:14 1.9K StringSymbol.java 24-Sep-2009 14:14 2.7K StringTable.java 24-Sep-2009 14:14 1.8K TokenConstants.java 24-Sep-2009 14:14 2.0K Utilities.java 24-Sep-2009 14:14 7.7K mycoolc 24-Sep-2009 14:14 65"},{"location":"software/cooldist/src/PA3/","title":"Index of /~aiken/software/cooldist/src/PA3","text":""},{"location":"software/cooldist/src/PA3/#index-of-aikensoftwarecooldistsrcpa3","title":"Index of /~aiken/software/cooldist/src/PA3","text":"Name Last modified Size Description Parent Directory - cool-tree.aps 24-Sep-2009 14:14 2.5K cool-tree.cc 24-Sep-2009 17:56 12K dumptype.cc 24-Sep-2009 14:14 13K handle_flags.cc 24-Sep-2009 14:14 3.2K mycoolc 24-Sep-2009 14:14 65 myparser 24-Sep-2009 14:14 39 parser-phase.cc 24-Sep-2009 14:14 1.2K stringtab.cc 24-Sep-2009 14:14 1.7K tokens-lex.cc 04-Oct-2009 14:30 64K tree.cc 24-Sep-2009 14:14 1.1K utilities.cc 24-Sep-2009 14:14 7.0K"},{"location":"software/cooldist/src/PA3J/","title":"Index of /~aiken/software/cooldist/src/PA3J","text":""},{"location":"software/cooldist/src/PA3J/#index-of-aikensoftwarecooldistsrcpa3j","title":"Index of /~aiken/software/cooldist/src/PA3J","text":"Name Last modified Size Description Parent Directory - AbstractSymbol.java 24-Sep-2009 14:14 3.6K AbstractTable.java 24-Sep-2009 14:14 7.2K BoolConst.java 24-Sep-2009 14:14 2.7K CgenClassTable.java 24-Sep-2009 14:14 14K CgenNode.java 24-Sep-2009 14:14 2.8K CgenSupport.java 24-Sep-2009 14:14 18K ClassTable.java 24-Sep-2009 14:14 8.3K CoolTokenLexer.java 24-Sep-2009 14:14 26K Flags.java 24-Sep-2009 14:14 4.1K IdSymbol.java 24-Sep-2009 14:14 1.4K IdTable.java 24-Sep-2009 14:14 1.2K IntSymbol.java 24-Sep-2009 14:14 2.4K IntTable.java 24-Sep-2009 14:14 1.7K ListNode.java 24-Sep-2009 14:14 5.3K Parser.java 24-Sep-2009 14:14 1.8K StringSymbol.java 24-Sep-2009 14:14 2.7K StringTable.java 24-Sep-2009 14:14 1.8K SymbolTable.java 24-Sep-2009 14:14 4.9K TreeConstants.java 24-Sep-2009 14:14 3.6K TreeNode.java 24-Sep-2009 14:14 12K Utilities.java 24-Sep-2009 14:14 7.7K cool-tree.aps 24-Sep-2009 14:14 2.5K cool-tree.java 18-Oct-2009 21:31 48K mycoolc 24-Sep-2009 14:14 65 myparser 24-Sep-2009 14:14 39"},{"location":"software/cooldist/src/PA4/","title":"Index of /~aiken/software/cooldist/src/PA4","text":""},{"location":"software/cooldist/src/PA4/#index-of-aikensoftwarecooldistsrcpa4","title":"Index of /~aiken/software/cooldist/src/PA4","text":"Name Last modified Size Description Parent Directory - ast-lex.cc 18-Oct-2009 21:05 60K ast-parse.cc 24-Sep-2009 17:56 57K cool-tree.aps 24-Sep-2009 14:14 2.5K cool-tree.cc 03-Nov-2009 17:35 12K dumptype.cc 24-Sep-2009 14:14 13K handle_flags.cc 24-Sep-2009 14:14 3.2K mycoolc 24-Sep-2009 14:14 65 mysemant 24-Sep-2009 14:14 54 semant-phase.cc 24-Sep-2009 14:14 521 stringtab.cc 24-Sep-2009 14:14 1.7K symtab_example.cc 24-Sep-2009 14:14 1.6K tree.cc 24-Sep-2009 14:14 1.1K utilities.cc 24-Sep-2009 14:14 7.0K"},{"location":"software/cooldist/src/PA4J/","title":"Index of /~aiken/software/cooldist/src/PA4J","text":""},{"location":"software/cooldist/src/PA4J/#index-of-aikensoftwarecooldistsrcpa4j","title":"Index of /~aiken/software/cooldist/src/PA4J","text":"Name Last modified Size Description Parent Directory - ASTConstants.java 24-Sep-2009 14:14 1.8K ASTLexer.java 24-Sep-2009 14:14 18K ASTParser.java 18-Oct-2009 21:28 41K AbstractSymbol.java 24-Sep-2009 14:14 3.6K AbstractTable.java 24-Sep-2009 14:14 7.2K BoolConst.java 24-Sep-2009 14:14 2.7K CgenSupport.java 24-Sep-2009 14:14 18K Flags.java 24-Sep-2009 14:14 4.1K IdSymbol.java 24-Sep-2009 14:14 1.4K IdTable.java 24-Sep-2009 14:14 1.2K IntSymbol.java 24-Sep-2009 14:14 2.4K IntTable.java 24-Sep-2009 14:14 1.7K ListNode.java 24-Sep-2009 14:14 5.3K Semant.java 24-Sep-2009 14:14 1.6K StringSymbol.java 24-Sep-2009 14:14 2.7K StringTable.java 24-Sep-2009 14:14 1.8K SymbolTable.java 24-Sep-2009 14:14 4.9K SymtabExample.java 24-Sep-2009 14:14 2.6K TokenConstants.java 24-Sep-2009 14:14 2.0K TreeNode.java 24-Sep-2009 14:14 12K Utilities.java 24-Sep-2009 14:14 7.7K cool-tree.aps 24-Sep-2009 14:14 2.5K mycoolc 24-Sep-2009 14:14 65 mysemant 24-Sep-2009 14:14 54"},{"location":"software/cooldist/src/PA5/","title":"Index of /~aiken/software/cooldist/src/PA5","text":""},{"location":"software/cooldist/src/PA5/#index-of-aikensoftwarecooldistsrcpa5","title":"Index of /~aiken/software/cooldist/src/PA5","text":"Name Last modified Size Description Parent Directory - ast-lex.cc 03-Nov-2009 17:20 60K ast-parse.cc 24-Sep-2009 17:56 57K cgen-phase.cc 24-Sep-2009 14:14 1.3K cool-tree.cc 03-Nov-2009 17:11 12K dumptype.cc 24-Sep-2009 14:14 13K handle_flags.cc 24-Sep-2009 14:14 3.2K mycoolc 24-Sep-2009 14:14 65 stringtab.cc 24-Sep-2009 14:14 1.7K tree.cc 24-Sep-2009 14:14 1.1K utilities.cc 24-Sep-2009 14:14 7.0K"},{"location":"software/cooldist/src/PA5J/","title":"Index of /~aiken/software/cooldist/src/PA5J","text":""},{"location":"software/cooldist/src/PA5J/#index-of-aikensoftwarecooldistsrcpa5j","title":"Index of /~aiken/software/cooldist/src/PA5J","text":"Name Last modified Size Description Parent Directory - ASTConstants.java 24-Sep-2009 14:14 1.8K ASTLexer.java 24-Sep-2009 14:14 18K ASTParser.java 03-Nov-2009 18:40 41K AbstractSymbol.java 24-Sep-2009 14:14 3.6K AbstractTable.java 24-Sep-2009 14:14 7.2K Cgen.java 24-Sep-2009 14:14 2.1K ClassTable.java 03-Nov-2009 18:38 8.3K Flags.java 24-Sep-2009 14:14 4.1K IdSymbol.java 24-Sep-2009 14:14 1.4K IdTable.java 24-Sep-2009 14:14 1.2K IntTable.java 24-Sep-2009 14:14 1.7K ListNode.java 24-Sep-2009 14:14 5.3K StringTable.java 24-Sep-2009 14:14 1.8K SymbolTable.java 24-Sep-2009 14:14 4.9K SymtabExample.java 24-Sep-2009 14:14 2.6K TokenConstants.java 24-Sep-2009 14:14 2.0K TreeNode.java 24-Sep-2009 14:14 12K Utilities.java 24-Sep-2009 14:14 7.7K cool-tree.aps 24-Sep-2009 14:14 2.5K mycoolc 24-Sep-2009 14:14 65"}]}